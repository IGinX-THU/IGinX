#
# IGinX - the polystore system with high performance
# Copyright (C) Tsinghua University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
 
#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class DataType(object):
    BOOLEAN = 0
    INTEGER = 1
    LONG = 2
    FLOAT = 3
    DOUBLE = 4
    BINARY = 5

    _VALUES_TO_NAMES = {
        0: "BOOLEAN",
        1: "INTEGER",
        2: "LONG",
        3: "FLOAT",
        4: "DOUBLE",
        5: "BINARY",
    }

    _NAMES_TO_VALUES = {
        "BOOLEAN": 0,
        "INTEGER": 1,
        "LONG": 2,
        "FLOAT": 3,
        "DOUBLE": 4,
        "BINARY": 5,
    }


class StorageEngineType(object):
    iotdb12 = 0
    influxdb = 1
    parquet = 2
    relational = 3
    mongodb = 4
    redis = 5
    filesystem = 6
    opentsdb = 7
    timescaledb = 8
    unknown = 9

    _VALUES_TO_NAMES = {
        0: "iotdb12",
        1: "influxdb",
        2: "parquet",
        3: "relational",
        4: "mongodb",
        5: "redis",
        6: "filesystem",
        7: "opentsdb",
        8: "timescaledb",
        9: "unknown",
    }

    _NAMES_TO_VALUES = {
        "iotdb12": 0,
        "influxdb": 1,
        "parquet": 2,
        "relational": 3,
        "mongodb": 4,
        "redis": 5,
        "filesystem": 6,
        "opentsdb": 7,
        "timescaledb": 8,
        "unknown": 9,
    }


class AggregateType(object):
    MAX = 0
    MIN = 1
    SUM = 2
    COUNT = 3
    AVG = 4
    FIRST_VALUE = 5
    LAST_VALUE = 6
    FIRST = 7
    LAST = 8

    _VALUES_TO_NAMES = {
        0: "MAX",
        1: "MIN",
        2: "SUM",
        3: "COUNT",
        4: "AVG",
        5: "FIRST_VALUE",
        6: "LAST_VALUE",
        7: "FIRST",
        8: "LAST",
    }

    _NAMES_TO_VALUES = {
        "MAX": 0,
        "MIN": 1,
        "SUM": 2,
        "COUNT": 3,
        "AVG": 4,
        "FIRST_VALUE": 5,
        "LAST_VALUE": 6,
        "FIRST": 7,
        "LAST": 8,
    }


class SqlType(object):
    Unknown = 0
    Insert = 1
    Delete = 2
    Query = 3
    GetReplicaNum = 4
    AddStorageEngines = 5
    CountPoints = 6
    ClearData = 7
    DeleteColumns = 8
    ShowColumns = 9
    ShowClusterInfo = 10
    ShowRegisterTask = 11
    RegisterTask = 12
    DropTask = 13
    CommitTransformJob = 14
    ShowJobStatus = 15
    CancelJob = 16
    ShowEligibleJob = 17
    RemoveHistoryDataSource = 18
    SetConfig = 19
    ShowConfig = 20
    Compact = 21
    ExportCsv = 22
    ExportStream = 23
    LoadCsv = 24
    ShowSessionID = 25
    ShowRules = 26
    SetRules = 27

    _VALUES_TO_NAMES = {
        0: "Unknown",
        1: "Insert",
        2: "Delete",
        3: "Query",
        4: "GetReplicaNum",
        5: "AddStorageEngines",
        6: "CountPoints",
        7: "ClearData",
        8: "DeleteColumns",
        9: "ShowColumns",
        10: "ShowClusterInfo",
        11: "ShowRegisterTask",
        12: "RegisterTask",
        13: "DropTask",
        14: "CommitTransformJob",
        15: "ShowJobStatus",
        16: "CancelJob",
        17: "ShowEligibleJob",
        18: "RemoveHistoryDataSource",
        19: "SetConfig",
        20: "ShowConfig",
        21: "Compact",
        22: "ExportCsv",
        23: "ExportStream",
        24: "LoadCsv",
        25: "ShowSessionID",
        26: "ShowRules",
        27: "SetRules",
    }

    _NAMES_TO_VALUES = {
        "Unknown": 0,
        "Insert": 1,
        "Delete": 2,
        "Query": 3,
        "GetReplicaNum": 4,
        "AddStorageEngines": 5,
        "CountPoints": 6,
        "ClearData": 7,
        "DeleteColumns": 8,
        "ShowColumns": 9,
        "ShowClusterInfo": 10,
        "ShowRegisterTask": 11,
        "RegisterTask": 12,
        "DropTask": 13,
        "CommitTransformJob": 14,
        "ShowJobStatus": 15,
        "CancelJob": 16,
        "ShowEligibleJob": 17,
        "RemoveHistoryDataSource": 18,
        "SetConfig": 19,
        "ShowConfig": 20,
        "Compact": 21,
        "ExportCsv": 22,
        "ExportStream": 23,
        "LoadCsv": 24,
        "ShowSessionID": 25,
        "ShowRules": 26,
        "SetRules": 27,
    }


class AuthType(object):
    Read = 0
    Write = 1
    Admin = 2
    Cluster = 3

    _VALUES_TO_NAMES = {
        0: "Read",
        1: "Write",
        2: "Admin",
        3: "Cluster",
    }

    _NAMES_TO_VALUES = {
        "Read": 0,
        "Write": 1,
        "Admin": 2,
        "Cluster": 3,
    }


class UserType(object):
    Administrator = 0
    OrdinaryUser = 1

    _VALUES_TO_NAMES = {
        0: "Administrator",
        1: "OrdinaryUser",
    }

    _NAMES_TO_VALUES = {
        "Administrator": 0,
        "OrdinaryUser": 1,
    }


class ExportType(object):
    Log = 0
    File = 1
    IginX = 2

    _VALUES_TO_NAMES = {
        0: "Log",
        1: "File",
        2: "IginX",
    }

    _NAMES_TO_VALUES = {
        "Log": 0,
        "File": 1,
        "IginX": 2,
    }


class TaskType(object):
    IginX = 0
    Python = 1

    _VALUES_TO_NAMES = {
        0: "IginX",
        1: "Python",
    }

    _NAMES_TO_VALUES = {
        "IginX": 0,
        "Python": 1,
    }


class DataFlowType(object):
    Batch = 0
    Stream = 1

    _VALUES_TO_NAMES = {
        0: "Batch",
        1: "Stream",
    }

    _NAMES_TO_VALUES = {
        "Batch": 0,
        "Stream": 1,
    }


class JobState(object):
    JOB_UNKNOWN = 0
    JOB_FINISHED = 1
    JOB_CREATED = 2
    JOB_RUNNING = 3
    JOB_FAILING = 4
    JOB_FAILED = 5
    JOB_CLOSING = 6
    JOB_CLOSED = 7

    _VALUES_TO_NAMES = {
        0: "JOB_UNKNOWN",
        1: "JOB_FINISHED",
        2: "JOB_CREATED",
        3: "JOB_RUNNING",
        4: "JOB_FAILING",
        5: "JOB_FAILED",
        6: "JOB_CLOSING",
        7: "JOB_CLOSED",
    }

    _NAMES_TO_VALUES = {
        "JOB_UNKNOWN": 0,
        "JOB_FINISHED": 1,
        "JOB_CREATED": 2,
        "JOB_RUNNING": 3,
        "JOB_FAILING": 4,
        "JOB_FAILED": 5,
        "JOB_CLOSING": 6,
        "JOB_CLOSED": 7,
    }


class UDFType(object):
    UDAF = 0
    UDTF = 1
    UDSF = 2
    TRANSFORM = 3

    _VALUES_TO_NAMES = {
        0: "UDAF",
        1: "UDTF",
        2: "UDSF",
        3: "TRANSFORM",
    }

    _NAMES_TO_VALUES = {
        "UDAF": 0,
        "UDTF": 1,
        "UDSF": 2,
        "TRANSFORM": 3,
    }


class TimePrecision(object):
    YEAR = 0
    MONTH = 1
    WEEK = 2
    DAY = 3
    HOUR = 4
    MIN = 5
    S = 6
    MS = 7
    US = 8
    NS = 9

    _VALUES_TO_NAMES = {
        0: "YEAR",
        1: "MONTH",
        2: "WEEK",
        3: "DAY",
        4: "HOUR",
        5: "MIN",
        6: "S",
        7: "MS",
        8: "US",
        9: "NS",
    }

    _NAMES_TO_VALUES = {
        "YEAR": 0,
        "MONTH": 1,
        "WEEK": 2,
        "DAY": 3,
        "HOUR": 4,
        "MIN": 5,
        "S": 6,
        "MS": 7,
        "US": 8,
        "NS": 9,
    }


class TagFilterType(object):
    Base = 0
    And = 1
    Or = 2
    BasePrecise = 3
    Precise = 4
    WithoutTag = 5

    _VALUES_TO_NAMES = {
        0: "Base",
        1: "And",
        2: "Or",
        3: "BasePrecise",
        4: "Precise",
        5: "WithoutTag",
    }

    _NAMES_TO_VALUES = {
        "Base": 0,
        "And": 1,
        "Or": 2,
        "BasePrecise": 3,
        "Precise": 4,
        "WithoutTag": 5,
    }


class DebugInfoType(object):
    GET_META = 0

    _VALUES_TO_NAMES = {
        0: "GET_META",
    }

    _NAMES_TO_VALUES = {
        "GET_META": 0,
    }


class Status(object):
    """
    Attributes:
     - code
     - message
     - subStatus

    """


    def __init__(self, code=None, message=None, subStatus=None,):
        self.code = code
        self.message = message
        self.subStatus = subStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.subStatus = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = Status()
                        _elem5.read(iprot)
                        self.subStatus.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Status')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.subStatus is not None:
            oprot.writeFieldBegin('subStatus', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.subStatus))
            for iter6 in self.subStatus:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.code is None:
            raise TProtocolException(message='Required field code is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UDFClassPair(object):
    """
    Attributes:
     - name
     - classPath

    """


    def __init__(self, name=None, classPath=None,):
        self.name = name
        self.classPath = classPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.classPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UDFClassPair')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.classPath is not None:
            oprot.writeFieldBegin('classPath', TType.STRING, 2)
            oprot.writeString(self.classPath.encode('utf-8') if sys.version_info[0] == 2 else self.classPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.classPath is None:
            raise TProtocolException(message='Required field classPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OpenSessionReq(object):
    """
    Attributes:
     - username
     - password

    """


    def __init__(self, username=None, password=None,):
        self.username = username
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OpenSessionReq')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OpenSessionResp(object):
    """
    Attributes:
     - status
     - sessionId

    """


    def __init__(self, status=None, sessionId=None,):
        self.status = status
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OpenSessionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 2)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CloseSessionReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CloseSessionReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeleteColumnsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - tagsList
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, tagsList=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.tagsList = tagsList
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = {}
                        (_ktype20, _vtype21, _size19) = iprot.readMapBegin()
                        for _i23 in range(_size19):
                            _key24 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val25 = []
                            (_etype29, _size26) = iprot.readListBegin()
                            for _i30 in range(_size26):
                                _elem31 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val25.append(_elem31)
                            iprot.readListEnd()
                            _elem18[_key24] = _val25
                        iprot.readMapEnd()
                        self.tagsList.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteColumnsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter32 in self.paths:
                oprot.writeString(iter32.encode('utf-8') if sys.version_info[0] == 2 else iter32)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter33 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter33))
                for kiter34, viter35 in iter33.items():
                    oprot.writeString(kiter34.encode('utf-8') if sys.version_info[0] == 2 else kiter34)
                    oprot.writeListBegin(TType.STRING, len(viter35))
                    for iter36 in viter35:
                        oprot.writeString(iter36.encode('utf-8') if sys.version_info[0] == 2 else iter36)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 4)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertColumnRecordsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - keys
     - valuesList
     - bitmapList
     - dataTypeList
     - tagsList
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, keys=None, valuesList=None, bitmapList=None, dataTypeList=None, tagsList=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList
        self.dataTypeList = dataTypeList
        self.tagsList = tagsList
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype46, _size43) = iprot.readListBegin()
                    for _i47 in range(_size43):
                        _elem48 = iprot.readBinary()
                        self.valuesList.append(_elem48)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readBinary()
                        self.bitmapList.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readI32()
                        self.dataTypeList.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = {}
                        (_ktype68, _vtype69, _size67) = iprot.readMapBegin()
                        for _i71 in range(_size67):
                            _key72 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val73 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem66[_key72] = _val73
                        iprot.readMapEnd()
                        self.tagsList.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertColumnRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter74 in self.paths:
                oprot.writeString(iter74.encode('utf-8') if sys.version_info[0] == 2 else iter74)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 3)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter75 in self.valuesList:
                oprot.writeBinary(iter75)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter76 in self.bitmapList:
                oprot.writeBinary(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter77 in self.dataTypeList:
                oprot.writeI32(iter77)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter78 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter78))
                for kiter79, viter80 in iter78.items():
                    oprot.writeString(kiter79.encode('utf-8') if sys.version_info[0] == 2 else kiter79)
                    oprot.writeString(viter80.encode('utf-8') if sys.version_info[0] == 2 else viter80)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        if self.dataTypeList is None:
            raise TProtocolException(message='Required field dataTypeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertNonAlignedColumnRecordsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - keys
     - valuesList
     - bitmapList
     - dataTypeList
     - tagsList
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, keys=None, valuesList=None, bitmapList=None, dataTypeList=None, tagsList=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList
        self.dataTypeList = dataTypeList
        self.tagsList = tagsList
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype90, _size87) = iprot.readListBegin()
                    for _i91 in range(_size87):
                        _elem92 = iprot.readBinary()
                        self.valuesList.append(_elem92)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype96, _size93) = iprot.readListBegin()
                    for _i97 in range(_size93):
                        _elem98 = iprot.readBinary()
                        self.bitmapList.append(_elem98)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype102, _size99) = iprot.readListBegin()
                    for _i103 in range(_size99):
                        _elem104 = iprot.readI32()
                        self.dataTypeList.append(_elem104)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = {}
                        (_ktype112, _vtype113, _size111) = iprot.readMapBegin()
                        for _i115 in range(_size111):
                            _key116 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val117 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem110[_key116] = _val117
                        iprot.readMapEnd()
                        self.tagsList.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertNonAlignedColumnRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter118 in self.paths:
                oprot.writeString(iter118.encode('utf-8') if sys.version_info[0] == 2 else iter118)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 3)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter119 in self.valuesList:
                oprot.writeBinary(iter119)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter120 in self.bitmapList:
                oprot.writeBinary(iter120)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter121 in self.dataTypeList:
                oprot.writeI32(iter121)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter122 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter122))
                for kiter123, viter124 in iter122.items():
                    oprot.writeString(kiter123.encode('utf-8') if sys.version_info[0] == 2 else kiter123)
                    oprot.writeString(viter124.encode('utf-8') if sys.version_info[0] == 2 else viter124)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        if self.dataTypeList is None:
            raise TProtocolException(message='Required field dataTypeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertRowRecordsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - keys
     - valuesList
     - bitmapList
     - dataTypeList
     - tagsList
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, keys=None, valuesList=None, bitmapList=None, dataTypeList=None, tagsList=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList
        self.dataTypeList = dataTypeList
        self.tagsList = tagsList
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype134, _size131) = iprot.readListBegin()
                    for _i135 in range(_size131):
                        _elem136 = iprot.readBinary()
                        self.valuesList.append(_elem136)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype140, _size137) = iprot.readListBegin()
                    for _i141 in range(_size137):
                        _elem142 = iprot.readBinary()
                        self.bitmapList.append(_elem142)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype146, _size143) = iprot.readListBegin()
                    for _i147 in range(_size143):
                        _elem148 = iprot.readI32()
                        self.dataTypeList.append(_elem148)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = {}
                        (_ktype156, _vtype157, _size155) = iprot.readMapBegin()
                        for _i159 in range(_size155):
                            _key160 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val161 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem154[_key160] = _val161
                        iprot.readMapEnd()
                        self.tagsList.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertRowRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter162 in self.paths:
                oprot.writeString(iter162.encode('utf-8') if sys.version_info[0] == 2 else iter162)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 3)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter163 in self.valuesList:
                oprot.writeBinary(iter163)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter164 in self.bitmapList:
                oprot.writeBinary(iter164)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter165 in self.dataTypeList:
                oprot.writeI32(iter165)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter166 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter166))
                for kiter167, viter168 in iter166.items():
                    oprot.writeString(kiter167.encode('utf-8') if sys.version_info[0] == 2 else kiter167)
                    oprot.writeString(viter168.encode('utf-8') if sys.version_info[0] == 2 else viter168)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        if self.dataTypeList is None:
            raise TProtocolException(message='Required field dataTypeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertNonAlignedRowRecordsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - keys
     - valuesList
     - bitmapList
     - dataTypeList
     - tagsList
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, keys=None, valuesList=None, bitmapList=None, dataTypeList=None, tagsList=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList
        self.dataTypeList = dataTypeList
        self.tagsList = tagsList
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype172, _size169) = iprot.readListBegin()
                    for _i173 in range(_size169):
                        _elem174 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem174)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype178, _size175) = iprot.readListBegin()
                    for _i179 in range(_size175):
                        _elem180 = iprot.readBinary()
                        self.valuesList.append(_elem180)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype184, _size181) = iprot.readListBegin()
                    for _i185 in range(_size181):
                        _elem186 = iprot.readBinary()
                        self.bitmapList.append(_elem186)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype190, _size187) = iprot.readListBegin()
                    for _i191 in range(_size187):
                        _elem192 = iprot.readI32()
                        self.dataTypeList.append(_elem192)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype196, _size193) = iprot.readListBegin()
                    for _i197 in range(_size193):
                        _elem198 = {}
                        (_ktype200, _vtype201, _size199) = iprot.readMapBegin()
                        for _i203 in range(_size199):
                            _key204 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val205 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem198[_key204] = _val205
                        iprot.readMapEnd()
                        self.tagsList.append(_elem198)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertNonAlignedRowRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter206 in self.paths:
                oprot.writeString(iter206.encode('utf-8') if sys.version_info[0] == 2 else iter206)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 3)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter207 in self.valuesList:
                oprot.writeBinary(iter207)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter208 in self.bitmapList:
                oprot.writeBinary(iter208)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter209 in self.dataTypeList:
                oprot.writeI32(iter209)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter210 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter210))
                for kiter211, viter212 in iter210.items():
                    oprot.writeString(kiter211.encode('utf-8') if sys.version_info[0] == 2 else kiter211)
                    oprot.writeString(viter212.encode('utf-8') if sys.version_info[0] == 2 else viter212)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        if self.dataTypeList is None:
            raise TProtocolException(message='Required field dataTypeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeleteDataInColumnsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - tagsList
     - filterType
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, tagsList=None, filterType=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.tagsList = tagsList
        self.filterType = filterType
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype216, _size213) = iprot.readListBegin()
                    for _i217 in range(_size213):
                        _elem218 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem218)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype222, _size219) = iprot.readListBegin()
                    for _i223 in range(_size219):
                        _elem224 = {}
                        (_ktype226, _vtype227, _size225) = iprot.readMapBegin()
                        for _i229 in range(_size225):
                            _key230 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val231 = []
                            (_etype235, _size232) = iprot.readListBegin()
                            for _i236 in range(_size232):
                                _elem237 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val231.append(_elem237)
                            iprot.readListEnd()
                            _elem224[_key230] = _val231
                        iprot.readMapEnd()
                        self.tagsList.append(_elem224)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteDataInColumnsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter238 in self.paths:
                oprot.writeString(iter238.encode('utf-8') if sys.version_info[0] == 2 else iter238)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 5)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter239 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter239))
                for kiter240, viter241 in iter239.items():
                    oprot.writeString(kiter240.encode('utf-8') if sys.version_info[0] == 2 else kiter240)
                    oprot.writeListBegin(TType.STRING, len(viter241))
                    for iter242 in viter241:
                        oprot.writeString(iter242.encode('utf-8') if sys.version_info[0] == 2 else iter242)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 6)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 7)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryDataSet(object):
    """
    Attributes:
     - keys
     - valuesList
     - bitmapList

    """


    def __init__(self, keys=None, valuesList=None, bitmapList=None,):
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype246, _size243) = iprot.readListBegin()
                    for _i247 in range(_size243):
                        _elem248 = iprot.readBinary()
                        self.valuesList.append(_elem248)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype252, _size249) = iprot.readListBegin()
                    for _i253 in range(_size249):
                        _elem254 = iprot.readBinary()
                        self.bitmapList.append(_elem254)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryDataSet')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 1)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter255 in self.valuesList:
                oprot.writeBinary(iter255)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter256 in self.bitmapList:
                oprot.writeBinary(iter256)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryDataReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - tagsList
     - timePrecision
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, tagsList=None, timePrecision=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.tagsList = tagsList
        self.timePrecision = timePrecision
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype260, _size257) = iprot.readListBegin()
                    for _i261 in range(_size257):
                        _elem262 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem262)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = {}
                        (_ktype270, _vtype271, _size269) = iprot.readMapBegin()
                        for _i273 in range(_size269):
                            _key274 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val275 = []
                            (_etype279, _size276) = iprot.readListBegin()
                            for _i280 in range(_size276):
                                _elem281 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val275.append(_elem281)
                            iprot.readListEnd()
                            _elem268[_key274] = _val275
                        iprot.readMapEnd()
                        self.tagsList.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryDataReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter282 in self.paths:
                oprot.writeString(iter282.encode('utf-8') if sys.version_info[0] == 2 else iter282)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 5)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter283 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter283))
                for kiter284, viter285 in iter283.items():
                    oprot.writeString(kiter284.encode('utf-8') if sys.version_info[0] == 2 else kiter284)
                    oprot.writeListBegin(TType.STRING, len(viter285))
                    for iter286 in viter285:
                        oprot.writeString(iter286.encode('utf-8') if sys.version_info[0] == 2 else iter286)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 6)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 7)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryDataResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList
     - queryDataSet

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None, queryDataSet=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype290, _size287) = iprot.readListBegin()
                    for _i291 in range(_size287):
                        _elem292 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem292)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype296, _size293) = iprot.readListBegin()
                    for _i297 in range(_size293):
                        _elem298 = {}
                        (_ktype300, _vtype301, _size299) = iprot.readMapBegin()
                        for _i303 in range(_size299):
                            _key304 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val305 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem298[_key304] = _val305
                        iprot.readMapEnd()
                        self.tagsList.append(_elem298)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype309, _size306) = iprot.readListBegin()
                    for _i310 in range(_size306):
                        _elem311 = iprot.readI32()
                        self.dataTypeList.append(_elem311)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryDataResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter312 in self.paths:
                oprot.writeString(iter312.encode('utf-8') if sys.version_info[0] == 2 else iter312)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter313 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter313))
                for kiter314, viter315 in iter313.items():
                    oprot.writeString(kiter314.encode('utf-8') if sys.version_info[0] == 2 else kiter314)
                    oprot.writeString(viter315.encode('utf-8') if sys.version_info[0] == 2 else viter315)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter316 in self.dataTypeList:
                oprot.writeI32(iter316)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 5)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddStorageEnginesReq(object):
    """
    Attributes:
     - sessionId
     - storageEngines

    """


    def __init__(self, sessionId=None, storageEngines=None,):
        self.sessionId = sessionId
        self.storageEngines = storageEngines

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.storageEngines = []
                    (_etype320, _size317) = iprot.readListBegin()
                    for _i321 in range(_size317):
                        _elem322 = StorageEngine()
                        _elem322.read(iprot)
                        self.storageEngines.append(_elem322)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddStorageEnginesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.storageEngines is not None:
            oprot.writeFieldBegin('storageEngines', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.storageEngines))
            for iter323 in self.storageEngines:
                iter323.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.storageEngines is None:
            raise TProtocolException(message='Required field storageEngines is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StorageEngine(object):
    """
    Attributes:
     - ip
     - port
     - type
     - extraParams

    """


    def __init__(self, ip=None, port=None, type=None, extraParams=None,):
        self.ip = ip
        self.port = port
        self.type = type
        self.extraParams = extraParams

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.extraParams = {}
                    (_ktype325, _vtype326, _size324) = iprot.readMapBegin()
                    for _i328 in range(_size324):
                        _key329 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val330 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.extraParams[_key329] = _val330
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StorageEngine')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.extraParams is not None:
            oprot.writeFieldBegin('extraParams', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraParams))
            for kiter331, viter332 in self.extraParams.items():
                oprot.writeString(kiter331.encode('utf-8') if sys.version_info[0] == 2 else kiter331)
                oprot.writeString(viter332.encode('utf-8') if sys.version_info[0] == 2 else viter332)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.extraParams is None:
            raise TProtocolException(message='Required field extraParams is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggregateQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - aggregateType
     - tagsList
     - timePrecision
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, aggregateType=None, tagsList=None, timePrecision=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.aggregateType = aggregateType
        self.tagsList = tagsList
        self.timePrecision = timePrecision
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype336, _size333) = iprot.readListBegin()
                    for _i337 in range(_size333):
                        _elem338 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem338)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.aggregateType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype342, _size339) = iprot.readListBegin()
                    for _i343 in range(_size339):
                        _elem344 = {}
                        (_ktype346, _vtype347, _size345) = iprot.readMapBegin()
                        for _i349 in range(_size345):
                            _key350 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val351 = []
                            (_etype355, _size352) = iprot.readListBegin()
                            for _i356 in range(_size352):
                                _elem357 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val351.append(_elem357)
                            iprot.readListEnd()
                            _elem344[_key350] = _val351
                        iprot.readMapEnd()
                        self.tagsList.append(_elem344)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggregateQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter358 in self.paths:
                oprot.writeString(iter358.encode('utf-8') if sys.version_info[0] == 2 else iter358)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.aggregateType is not None:
            oprot.writeFieldBegin('aggregateType', TType.I32, 5)
            oprot.writeI32(self.aggregateType)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 6)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter359 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter359))
                for kiter360, viter361 in iter359.items():
                    oprot.writeString(kiter360.encode('utf-8') if sys.version_info[0] == 2 else kiter360)
                    oprot.writeListBegin(TType.STRING, len(viter361))
                    for iter362 in viter361:
                        oprot.writeString(iter362.encode('utf-8') if sys.version_info[0] == 2 else iter362)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 7)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 8)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        if self.aggregateType is None:
            raise TProtocolException(message='Required field aggregateType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggregateQueryResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList
     - keys
     - valuesList

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None, keys=None, valuesList=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.keys = keys
        self.valuesList = valuesList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype366, _size363) = iprot.readListBegin()
                    for _i367 in range(_size363):
                        _elem368 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem368)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype372, _size369) = iprot.readListBegin()
                    for _i373 in range(_size369):
                        _elem374 = {}
                        (_ktype376, _vtype377, _size375) = iprot.readMapBegin()
                        for _i379 in range(_size375):
                            _key380 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val381 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem374[_key380] = _val381
                        iprot.readMapEnd()
                        self.tagsList.append(_elem374)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype385, _size382) = iprot.readListBegin()
                    for _i386 in range(_size382):
                        _elem387 = iprot.readI32()
                        self.dataTypeList.append(_elem387)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.valuesList = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggregateQueryResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter388 in self.paths:
                oprot.writeString(iter388.encode('utf-8') if sys.version_info[0] == 2 else iter388)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter389 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter389))
                for kiter390, viter391 in iter389.items():
                    oprot.writeString(kiter390.encode('utf-8') if sys.version_info[0] == 2 else kiter390)
                    oprot.writeString(viter391.encode('utf-8') if sys.version_info[0] == 2 else viter391)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter392 in self.dataTypeList:
                oprot.writeI32(iter392)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 5)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.STRING, 6)
            oprot.writeBinary(self.valuesList)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LastQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - tagsList
     - timePrecision
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, tagsList=None, timePrecision=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.tagsList = tagsList
        self.timePrecision = timePrecision
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype396, _size393) = iprot.readListBegin()
                    for _i397 in range(_size393):
                        _elem398 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem398)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype402, _size399) = iprot.readListBegin()
                    for _i403 in range(_size399):
                        _elem404 = {}
                        (_ktype406, _vtype407, _size405) = iprot.readMapBegin()
                        for _i409 in range(_size405):
                            _key410 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val411 = []
                            (_etype415, _size412) = iprot.readListBegin()
                            for _i416 in range(_size412):
                                _elem417 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val411.append(_elem417)
                            iprot.readListEnd()
                            _elem404[_key410] = _val411
                        iprot.readMapEnd()
                        self.tagsList.append(_elem404)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LastQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter418 in self.paths:
                oprot.writeString(iter418.encode('utf-8') if sys.version_info[0] == 2 else iter418)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 4)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter419 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter419))
                for kiter420, viter421 in iter419.items():
                    oprot.writeString(kiter420.encode('utf-8') if sys.version_info[0] == 2 else kiter420)
                    oprot.writeListBegin(TType.STRING, len(viter421))
                    for iter422 in viter421:
                        oprot.writeString(iter422.encode('utf-8') if sys.version_info[0] == 2 else iter422)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 5)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 6)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LastQueryResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList
     - queryDataSet

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None, queryDataSet=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype426, _size423) = iprot.readListBegin()
                    for _i427 in range(_size423):
                        _elem428 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem428)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype432, _size429) = iprot.readListBegin()
                    for _i433 in range(_size429):
                        _elem434 = {}
                        (_ktype436, _vtype437, _size435) = iprot.readMapBegin()
                        for _i439 in range(_size435):
                            _key440 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val441 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem434[_key440] = _val441
                        iprot.readMapEnd()
                        self.tagsList.append(_elem434)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype445, _size442) = iprot.readListBegin()
                    for _i446 in range(_size442):
                        _elem447 = iprot.readI32()
                        self.dataTypeList.append(_elem447)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LastQueryResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter448 in self.paths:
                oprot.writeString(iter448.encode('utf-8') if sys.version_info[0] == 2 else iter448)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter449 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter449))
                for kiter450, viter451 in iter449.items():
                    oprot.writeString(kiter450.encode('utf-8') if sys.version_info[0] == 2 else kiter450)
                    oprot.writeString(viter451.encode('utf-8') if sys.version_info[0] == 2 else viter451)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter452 in self.dataTypeList:
                oprot.writeI32(iter452)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 5)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DownsampleQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - aggregateType
     - precision
     - tagsList
     - timePrecision
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, aggregateType=None, precision=None, tagsList=None, timePrecision=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.aggregateType = aggregateType
        self.precision = precision
        self.tagsList = tagsList
        self.timePrecision = timePrecision
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype456, _size453) = iprot.readListBegin()
                    for _i457 in range(_size453):
                        _elem458 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem458)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.aggregateType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.precision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype462, _size459) = iprot.readListBegin()
                    for _i463 in range(_size459):
                        _elem464 = {}
                        (_ktype466, _vtype467, _size465) = iprot.readMapBegin()
                        for _i469 in range(_size465):
                            _key470 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val471 = []
                            (_etype475, _size472) = iprot.readListBegin()
                            for _i476 in range(_size472):
                                _elem477 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val471.append(_elem477)
                            iprot.readListEnd()
                            _elem464[_key470] = _val471
                        iprot.readMapEnd()
                        self.tagsList.append(_elem464)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DownsampleQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter478 in self.paths:
                oprot.writeString(iter478.encode('utf-8') if sys.version_info[0] == 2 else iter478)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.aggregateType is not None:
            oprot.writeFieldBegin('aggregateType', TType.I32, 5)
            oprot.writeI32(self.aggregateType)
            oprot.writeFieldEnd()
        if self.precision is not None:
            oprot.writeFieldBegin('precision', TType.I64, 6)
            oprot.writeI64(self.precision)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter479 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter479))
                for kiter480, viter481 in iter479.items():
                    oprot.writeString(kiter480.encode('utf-8') if sys.version_info[0] == 2 else kiter480)
                    oprot.writeListBegin(TType.STRING, len(viter481))
                    for iter482 in viter481:
                        oprot.writeString(iter482.encode('utf-8') if sys.version_info[0] == 2 else iter482)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 9)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        if self.aggregateType is None:
            raise TProtocolException(message='Required field aggregateType is unset!')
        if self.precision is None:
            raise TProtocolException(message='Required field precision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DownsampleQueryResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList
     - queryDataSet

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None, queryDataSet=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype486, _size483) = iprot.readListBegin()
                    for _i487 in range(_size483):
                        _elem488 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem488)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype492, _size489) = iprot.readListBegin()
                    for _i493 in range(_size489):
                        _elem494 = {}
                        (_ktype496, _vtype497, _size495) = iprot.readMapBegin()
                        for _i499 in range(_size495):
                            _key500 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val501 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem494[_key500] = _val501
                        iprot.readMapEnd()
                        self.tagsList.append(_elem494)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype505, _size502) = iprot.readListBegin()
                    for _i506 in range(_size502):
                        _elem507 = iprot.readI32()
                        self.dataTypeList.append(_elem507)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DownsampleQueryResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter508 in self.paths:
                oprot.writeString(iter508.encode('utf-8') if sys.version_info[0] == 2 else iter508)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter509 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter509))
                for kiter510, viter511 in iter509.items():
                    oprot.writeString(kiter510.encode('utf-8') if sys.version_info[0] == 2 else kiter510)
                    oprot.writeString(viter511.encode('utf-8') if sys.version_info[0] == 2 else viter511)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter512 in self.dataTypeList:
                oprot.writeI32(iter512)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 5)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowColumnsReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowColumnsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowColumnsResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype516, _size513) = iprot.readListBegin()
                    for _i517 in range(_size513):
                        _elem518 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem518)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype522, _size519) = iprot.readListBegin()
                    for _i523 in range(_size519):
                        _elem524 = {}
                        (_ktype526, _vtype527, _size525) = iprot.readMapBegin()
                        for _i529 in range(_size525):
                            _key530 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val531 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem524[_key530] = _val531
                        iprot.readMapEnd()
                        self.tagsList.append(_elem524)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype535, _size532) = iprot.readListBegin()
                    for _i536 in range(_size532):
                        _elem537 = iprot.readI32()
                        self.dataTypeList.append(_elem537)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowColumnsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter538 in self.paths:
                oprot.writeString(iter538.encode('utf-8') if sys.version_info[0] == 2 else iter538)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter539 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter539))
                for kiter540, viter541 in iter539.items():
                    oprot.writeString(kiter540.encode('utf-8') if sys.version_info[0] == 2 else kiter540)
                    oprot.writeString(viter541.encode('utf-8') if sys.version_info[0] == 2 else viter541)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter542 in self.dataTypeList:
                oprot.writeI32(iter542)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetReplicaNumReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetReplicaNumReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetReplicaNumResp(object):
    """
    Attributes:
     - status
     - replicaNum

    """


    def __init__(self, status=None, replicaNum=None,):
        self.status = status
        self.replicaNum = replicaNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.replicaNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetReplicaNumResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.replicaNum is not None:
            oprot.writeFieldBegin('replicaNum', TType.I32, 2)
            oprot.writeI32(self.replicaNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteSqlReq(object):
    """
    Attributes:
     - sessionId
     - statement

    """


    def __init__(self, sessionId=None, statement=None,):
        self.sessionId = sessionId
        self.statement = statement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteSqlReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteSqlResp(object):
    """
    Attributes:
     - status
     - type
     - paths
     - tagsList
     - dataTypeList
     - queryDataSet
     - keys
     - valuesList
     - replicaNum
     - pointsNum
     - aggregateType
     - parseErrorMsg
     - limit
     - offset
     - orderByPath
     - ascending
     - iginxInfos
     - storageEngineInfos
     - metaStorageInfos
     - localMetaStorageInfo
     - registerTaskInfos
     - jobId
     - jobState
     - jobIdList
     - configs
     - loadCsvPath
     - sessionIDList
     - rules
     - UDFModulePath

    """


    def __init__(self, status=None, type=None, paths=None, tagsList=None, dataTypeList=None, queryDataSet=None, keys=None, valuesList=None, replicaNum=None, pointsNum=None, aggregateType=None, parseErrorMsg=None, limit=None, offset=None, orderByPath=None, ascending=None, iginxInfos=None, storageEngineInfos=None, metaStorageInfos=None, localMetaStorageInfo=None, registerTaskInfos=None, jobId=None, jobState=None, jobIdList=None, configs=None, loadCsvPath=None, sessionIDList=None, rules=None, UDFModulePath=None,):
        self.status = status
        self.type = type
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet
        self.keys = keys
        self.valuesList = valuesList
        self.replicaNum = replicaNum
        self.pointsNum = pointsNum
        self.aggregateType = aggregateType
        self.parseErrorMsg = parseErrorMsg
        self.limit = limit
        self.offset = offset
        self.orderByPath = orderByPath
        self.ascending = ascending
        self.iginxInfos = iginxInfos
        self.storageEngineInfos = storageEngineInfos
        self.metaStorageInfos = metaStorageInfos
        self.localMetaStorageInfo = localMetaStorageInfo
        self.registerTaskInfos = registerTaskInfos
        self.jobId = jobId
        self.jobState = jobState
        self.jobIdList = jobIdList
        self.configs = configs
        self.loadCsvPath = loadCsvPath
        self.sessionIDList = sessionIDList
        self.rules = rules
        self.UDFModulePath = UDFModulePath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype546, _size543) = iprot.readListBegin()
                    for _i547 in range(_size543):
                        _elem548 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem548)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype552, _size549) = iprot.readListBegin()
                    for _i553 in range(_size549):
                        _elem554 = {}
                        (_ktype556, _vtype557, _size555) = iprot.readMapBegin()
                        for _i559 in range(_size555):
                            _key560 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val561 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem554[_key560] = _val561
                        iprot.readMapEnd()
                        self.tagsList.append(_elem554)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype565, _size562) = iprot.readListBegin()
                    for _i566 in range(_size562):
                        _elem567 = iprot.readI32()
                        self.dataTypeList.append(_elem567)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.valuesList = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.replicaNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.pointsNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.aggregateType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.parseErrorMsg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.orderByPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.ascending = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.LIST:
                    self.iginxInfos = []
                    (_etype571, _size568) = iprot.readListBegin()
                    for _i572 in range(_size568):
                        _elem573 = IginxInfo()
                        _elem573.read(iprot)
                        self.iginxInfos.append(_elem573)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.LIST:
                    self.storageEngineInfos = []
                    (_etype577, _size574) = iprot.readListBegin()
                    for _i578 in range(_size574):
                        _elem579 = StorageEngineInfo()
                        _elem579.read(iprot)
                        self.storageEngineInfos.append(_elem579)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.LIST:
                    self.metaStorageInfos = []
                    (_etype583, _size580) = iprot.readListBegin()
                    for _i584 in range(_size580):
                        _elem585 = MetaStorageInfo()
                        _elem585.read(iprot)
                        self.metaStorageInfos.append(_elem585)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.localMetaStorageInfo = LocalMetaStorageInfo()
                    self.localMetaStorageInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.LIST:
                    self.registerTaskInfos = []
                    (_etype589, _size586) = iprot.readListBegin()
                    for _i590 in range(_size586):
                        _elem591 = RegisterTaskInfo()
                        _elem591.read(iprot)
                        self.registerTaskInfos.append(_elem591)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I32:
                    self.jobState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.LIST:
                    self.jobIdList = []
                    (_etype595, _size592) = iprot.readListBegin()
                    for _i596 in range(_size592):
                        _elem597 = iprot.readI64()
                        self.jobIdList.append(_elem597)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.MAP:
                    self.configs = {}
                    (_ktype599, _vtype600, _size598) = iprot.readMapBegin()
                    for _i602 in range(_size598):
                        _key603 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val604 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configs[_key603] = _val604
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.STRING:
                    self.loadCsvPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.LIST:
                    self.sessionIDList = []
                    (_etype608, _size605) = iprot.readListBegin()
                    for _i609 in range(_size605):
                        _elem610 = iprot.readI64()
                        self.sessionIDList.append(_elem610)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.MAP:
                    self.rules = {}
                    (_ktype612, _vtype613, _size611) = iprot.readMapBegin()
                    for _i615 in range(_size611):
                        _key616 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val617 = iprot.readBool()
                        self.rules[_key616] = _val617
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.STRING:
                    self.UDFModulePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteSqlResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter618 in self.paths:
                oprot.writeString(iter618.encode('utf-8') if sys.version_info[0] == 2 else iter618)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 4)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter619 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter619))
                for kiter620, viter621 in iter619.items():
                    oprot.writeString(kiter620.encode('utf-8') if sys.version_info[0] == 2 else kiter620)
                    oprot.writeString(viter621.encode('utf-8') if sys.version_info[0] == 2 else viter621)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter622 in self.dataTypeList:
                oprot.writeI32(iter622)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 6)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 7)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.STRING, 8)
            oprot.writeBinary(self.valuesList)
            oprot.writeFieldEnd()
        if self.replicaNum is not None:
            oprot.writeFieldBegin('replicaNum', TType.I32, 9)
            oprot.writeI32(self.replicaNum)
            oprot.writeFieldEnd()
        if self.pointsNum is not None:
            oprot.writeFieldBegin('pointsNum', TType.I64, 10)
            oprot.writeI64(self.pointsNum)
            oprot.writeFieldEnd()
        if self.aggregateType is not None:
            oprot.writeFieldBegin('aggregateType', TType.I32, 11)
            oprot.writeI32(self.aggregateType)
            oprot.writeFieldEnd()
        if self.parseErrorMsg is not None:
            oprot.writeFieldBegin('parseErrorMsg', TType.STRING, 12)
            oprot.writeString(self.parseErrorMsg.encode('utf-8') if sys.version_info[0] == 2 else self.parseErrorMsg)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 13)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 14)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.orderByPath is not None:
            oprot.writeFieldBegin('orderByPath', TType.STRING, 15)
            oprot.writeString(self.orderByPath.encode('utf-8') if sys.version_info[0] == 2 else self.orderByPath)
            oprot.writeFieldEnd()
        if self.ascending is not None:
            oprot.writeFieldBegin('ascending', TType.BOOL, 16)
            oprot.writeBool(self.ascending)
            oprot.writeFieldEnd()
        if self.iginxInfos is not None:
            oprot.writeFieldBegin('iginxInfos', TType.LIST, 17)
            oprot.writeListBegin(TType.STRUCT, len(self.iginxInfos))
            for iter623 in self.iginxInfos:
                iter623.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageEngineInfos is not None:
            oprot.writeFieldBegin('storageEngineInfos', TType.LIST, 18)
            oprot.writeListBegin(TType.STRUCT, len(self.storageEngineInfos))
            for iter624 in self.storageEngineInfos:
                iter624.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metaStorageInfos is not None:
            oprot.writeFieldBegin('metaStorageInfos', TType.LIST, 19)
            oprot.writeListBegin(TType.STRUCT, len(self.metaStorageInfos))
            for iter625 in self.metaStorageInfos:
                iter625.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.localMetaStorageInfo is not None:
            oprot.writeFieldBegin('localMetaStorageInfo', TType.STRUCT, 20)
            self.localMetaStorageInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.registerTaskInfos is not None:
            oprot.writeFieldBegin('registerTaskInfos', TType.LIST, 21)
            oprot.writeListBegin(TType.STRUCT, len(self.registerTaskInfos))
            for iter626 in self.registerTaskInfos:
                iter626.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 22)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        if self.jobState is not None:
            oprot.writeFieldBegin('jobState', TType.I32, 23)
            oprot.writeI32(self.jobState)
            oprot.writeFieldEnd()
        if self.jobIdList is not None:
            oprot.writeFieldBegin('jobIdList', TType.LIST, 24)
            oprot.writeListBegin(TType.I64, len(self.jobIdList))
            for iter627 in self.jobIdList:
                oprot.writeI64(iter627)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.configs is not None:
            oprot.writeFieldBegin('configs', TType.MAP, 25)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configs))
            for kiter628, viter629 in self.configs.items():
                oprot.writeString(kiter628.encode('utf-8') if sys.version_info[0] == 2 else kiter628)
                oprot.writeString(viter629.encode('utf-8') if sys.version_info[0] == 2 else viter629)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.loadCsvPath is not None:
            oprot.writeFieldBegin('loadCsvPath', TType.STRING, 26)
            oprot.writeString(self.loadCsvPath.encode('utf-8') if sys.version_info[0] == 2 else self.loadCsvPath)
            oprot.writeFieldEnd()
        if self.sessionIDList is not None:
            oprot.writeFieldBegin('sessionIDList', TType.LIST, 27)
            oprot.writeListBegin(TType.I64, len(self.sessionIDList))
            for iter630 in self.sessionIDList:
                oprot.writeI64(iter630)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rules is not None:
            oprot.writeFieldBegin('rules', TType.MAP, 28)
            oprot.writeMapBegin(TType.STRING, TType.BOOL, len(self.rules))
            for kiter631, viter632 in self.rules.items():
                oprot.writeString(kiter631.encode('utf-8') if sys.version_info[0] == 2 else kiter631)
                oprot.writeBool(viter632)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.UDFModulePath is not None:
            oprot.writeFieldBegin('UDFModulePath', TType.STRING, 29)
            oprot.writeString(self.UDFModulePath.encode('utf-8') if sys.version_info[0] == 2 else self.UDFModulePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UpdateUserReq(object):
    """
    Attributes:
     - sessionId
     - username
     - password
     - auths

    """


    def __init__(self, sessionId=None, username=None, password=None, auths=None,):
        self.sessionId = sessionId
        self.username = username
        self.password = password
        self.auths = auths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.auths = set()
                    (_etype636, _size633) = iprot.readSetBegin()
                    for _i637 in range(_size633):
                        _elem638 = iprot.readI32()
                        self.auths.add(_elem638)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateUserReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 3)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.auths is not None:
            oprot.writeFieldBegin('auths', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.auths))
            for iter639 in self.auths:
                oprot.writeI32(iter639)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddUserReq(object):
    """
    Attributes:
     - sessionId
     - username
     - password
     - auths

    """


    def __init__(self, sessionId=None, username=None, password=None, auths=None,):
        self.sessionId = sessionId
        self.username = username
        self.password = password
        self.auths = auths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.auths = set()
                    (_etype643, _size640) = iprot.readSetBegin()
                    for _i644 in range(_size640):
                        _elem645 = iprot.readI32()
                        self.auths.add(_elem645)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddUserReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 3)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.auths is not None:
            oprot.writeFieldBegin('auths', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.auths))
            for iter646 in self.auths:
                oprot.writeI32(iter646)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.auths is None:
            raise TProtocolException(message='Required field auths is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeleteUserReq(object):
    """
    Attributes:
     - sessionId
     - username

    """


    def __init__(self, sessionId=None, username=None,):
        self.sessionId = sessionId
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteUserReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetUserReq(object):
    """
    Attributes:
     - sessionId
     - usernames

    """


    def __init__(self, sessionId=None, usernames=None,):
        self.sessionId = sessionId
        self.usernames = usernames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.usernames = []
                    (_etype650, _size647) = iprot.readListBegin()
                    for _i651 in range(_size647):
                        _elem652 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.usernames.append(_elem652)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetUserReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.usernames is not None:
            oprot.writeFieldBegin('usernames', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.usernames))
            for iter653 in self.usernames:
                oprot.writeString(iter653.encode('utf-8') if sys.version_info[0] == 2 else iter653)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetUserResp(object):
    """
    Attributes:
     - status
     - usernames
     - userTypes
     - auths

    """


    def __init__(self, status=None, usernames=None, userTypes=None, auths=None,):
        self.status = status
        self.usernames = usernames
        self.userTypes = userTypes
        self.auths = auths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.usernames = []
                    (_etype657, _size654) = iprot.readListBegin()
                    for _i658 in range(_size654):
                        _elem659 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.usernames.append(_elem659)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.userTypes = []
                    (_etype663, _size660) = iprot.readListBegin()
                    for _i664 in range(_size660):
                        _elem665 = iprot.readI32()
                        self.userTypes.append(_elem665)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.auths = []
                    (_etype669, _size666) = iprot.readListBegin()
                    for _i670 in range(_size666):
                        _elem671 = set()
                        (_etype675, _size672) = iprot.readSetBegin()
                        for _i676 in range(_size672):
                            _elem677 = iprot.readI32()
                            _elem671.add(_elem677)
                        iprot.readSetEnd()
                        self.auths.append(_elem671)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetUserResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.usernames is not None:
            oprot.writeFieldBegin('usernames', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.usernames))
            for iter678 in self.usernames:
                oprot.writeString(iter678.encode('utf-8') if sys.version_info[0] == 2 else iter678)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userTypes is not None:
            oprot.writeFieldBegin('userTypes', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.userTypes))
            for iter679 in self.userTypes:
                oprot.writeI32(iter679)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.auths is not None:
            oprot.writeFieldBegin('auths', TType.LIST, 4)
            oprot.writeListBegin(TType.SET, len(self.auths))
            for iter680 in self.auths:
                oprot.writeSetBegin(TType.I32, len(iter680))
                for iter681 in iter680:
                    oprot.writeI32(iter681)
                oprot.writeSetEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetClusterInfoReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetClusterInfoReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IginxInfo(object):
    """
    Attributes:
     - id
     - ip
     - port

    """


    def __init__(self, id=None, ip=None, port=None,):
        self.id = id
        self.ip = ip
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IginxInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 2)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StorageEngineInfo(object):
    """
    Attributes:
     - id
     - ip
     - port
     - type
     - schemaPrefix
     - dataPrefix

    """


    def __init__(self, id=None, ip=None, port=None, type=None, schemaPrefix=None, dataPrefix=None,):
        self.id = id
        self.ip = ip
        self.port = port
        self.type = type
        self.schemaPrefix = schemaPrefix
        self.dataPrefix = dataPrefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.schemaPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.dataPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StorageEngineInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 2)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.schemaPrefix is not None:
            oprot.writeFieldBegin('schemaPrefix', TType.STRING, 5)
            oprot.writeString(self.schemaPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.schemaPrefix)
            oprot.writeFieldEnd()
        if self.dataPrefix is not None:
            oprot.writeFieldBegin('dataPrefix', TType.STRING, 6)
            oprot.writeString(self.dataPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.dataPrefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MetaStorageInfo(object):
    """
    Attributes:
     - ip
     - port
     - type

    """


    def __init__(self, ip=None, port=None, type=None,):
        self.ip = ip
        self.port = port
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MetaStorageInfo')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 3)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LocalMetaStorageInfo(object):
    """
    Attributes:
     - path

    """


    def __init__(self, path=None,):
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LocalMetaStorageInfo')
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 1)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetClusterInfoResp(object):
    """
    Attributes:
     - status
     - iginxInfos
     - storageEngineInfos
     - metaStorageInfos
     - localMetaStorageInfo

    """


    def __init__(self, status=None, iginxInfos=None, storageEngineInfos=None, metaStorageInfos=None, localMetaStorageInfo=None,):
        self.status = status
        self.iginxInfos = iginxInfos
        self.storageEngineInfos = storageEngineInfos
        self.metaStorageInfos = metaStorageInfos
        self.localMetaStorageInfo = localMetaStorageInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.iginxInfos = []
                    (_etype685, _size682) = iprot.readListBegin()
                    for _i686 in range(_size682):
                        _elem687 = IginxInfo()
                        _elem687.read(iprot)
                        self.iginxInfos.append(_elem687)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.storageEngineInfos = []
                    (_etype691, _size688) = iprot.readListBegin()
                    for _i692 in range(_size688):
                        _elem693 = StorageEngineInfo()
                        _elem693.read(iprot)
                        self.storageEngineInfos.append(_elem693)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.metaStorageInfos = []
                    (_etype697, _size694) = iprot.readListBegin()
                    for _i698 in range(_size694):
                        _elem699 = MetaStorageInfo()
                        _elem699.read(iprot)
                        self.metaStorageInfos.append(_elem699)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.localMetaStorageInfo = LocalMetaStorageInfo()
                    self.localMetaStorageInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetClusterInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.iginxInfos is not None:
            oprot.writeFieldBegin('iginxInfos', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.iginxInfos))
            for iter700 in self.iginxInfos:
                iter700.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageEngineInfos is not None:
            oprot.writeFieldBegin('storageEngineInfos', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.storageEngineInfos))
            for iter701 in self.storageEngineInfos:
                iter701.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metaStorageInfos is not None:
            oprot.writeFieldBegin('metaStorageInfos', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.metaStorageInfos))
            for iter702 in self.metaStorageInfos:
                iter702.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.localMetaStorageInfo is not None:
            oprot.writeFieldBegin('localMetaStorageInfo', TType.STRUCT, 5)
            self.localMetaStorageInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteStatementReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - fetchSize
     - timeout

    """


    def __init__(self, sessionId=None, statement=None, fetchSize=None, timeout=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 4)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteStatementResp(object):
    """
    Attributes:
     - status
     - type
     - queryId
     - columns
     - tagsList
     - dataTypeList
     - queryDataSet
     - warningMsg
     - exportStreamDir
     - exportCSV

    """


    def __init__(self, status=None, type=None, queryId=None, columns=None, tagsList=None, dataTypeList=None, queryDataSet=None, warningMsg=None, exportStreamDir=None, exportCSV=None,):
        self.status = status
        self.type = type
        self.queryId = queryId
        self.columns = columns
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet
        self.warningMsg = warningMsg
        self.exportStreamDir = exportStreamDir
        self.exportCSV = exportCSV

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype706, _size703) = iprot.readListBegin()
                    for _i707 in range(_size703):
                        _elem708 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem708)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype712, _size709) = iprot.readListBegin()
                    for _i713 in range(_size709):
                        _elem714 = {}
                        (_ktype716, _vtype717, _size715) = iprot.readMapBegin()
                        for _i719 in range(_size715):
                            _key720 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val721 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem714[_key720] = _val721
                        iprot.readMapEnd()
                        self.tagsList.append(_elem714)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype725, _size722) = iprot.readListBegin()
                    for _i726 in range(_size722):
                        _elem727 = iprot.readI32()
                        self.dataTypeList.append(_elem727)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSetV2()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.warningMsg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.exportStreamDir = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.exportCSV = ExportCSV()
                    self.exportCSV.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteStatementResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 3)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter728 in self.columns:
                oprot.writeString(iter728.encode('utf-8') if sys.version_info[0] == 2 else iter728)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 5)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter729 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter729))
                for kiter730, viter731 in iter729.items():
                    oprot.writeString(kiter730.encode('utf-8') if sys.version_info[0] == 2 else kiter730)
                    oprot.writeString(viter731.encode('utf-8') if sys.version_info[0] == 2 else viter731)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter732 in self.dataTypeList:
                oprot.writeI32(iter732)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 7)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.warningMsg is not None:
            oprot.writeFieldBegin('warningMsg', TType.STRING, 8)
            oprot.writeString(self.warningMsg.encode('utf-8') if sys.version_info[0] == 2 else self.warningMsg)
            oprot.writeFieldEnd()
        if self.exportStreamDir is not None:
            oprot.writeFieldBegin('exportStreamDir', TType.STRING, 9)
            oprot.writeString(self.exportStreamDir.encode('utf-8') if sys.version_info[0] == 2 else self.exportStreamDir)
            oprot.writeFieldEnd()
        if self.exportCSV is not None:
            oprot.writeFieldBegin('exportCSV', TType.STRUCT, 10)
            self.exportCSV.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExportCSV(object):
    """
    Attributes:
     - exportCsvPath
     - isExportHeader
     - delimiter
     - isOptionallyQuote
     - quote
     - escaped
     - recordSeparator

    """


    def __init__(self, exportCsvPath=None, isExportHeader=None, delimiter=None, isOptionallyQuote=None, quote=None, escaped=None, recordSeparator=None,):
        self.exportCsvPath = exportCsvPath
        self.isExportHeader = isExportHeader
        self.delimiter = delimiter
        self.isOptionallyQuote = isOptionallyQuote
        self.quote = quote
        self.escaped = escaped
        self.recordSeparator = recordSeparator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.exportCsvPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isExportHeader = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.delimiter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isOptionallyQuote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.quote = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I16:
                    self.escaped = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.recordSeparator = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExportCSV')
        if self.exportCsvPath is not None:
            oprot.writeFieldBegin('exportCsvPath', TType.STRING, 1)
            oprot.writeString(self.exportCsvPath.encode('utf-8') if sys.version_info[0] == 2 else self.exportCsvPath)
            oprot.writeFieldEnd()
        if self.isExportHeader is not None:
            oprot.writeFieldBegin('isExportHeader', TType.BOOL, 2)
            oprot.writeBool(self.isExportHeader)
            oprot.writeFieldEnd()
        if self.delimiter is not None:
            oprot.writeFieldBegin('delimiter', TType.STRING, 3)
            oprot.writeString(self.delimiter.encode('utf-8') if sys.version_info[0] == 2 else self.delimiter)
            oprot.writeFieldEnd()
        if self.isOptionallyQuote is not None:
            oprot.writeFieldBegin('isOptionallyQuote', TType.BOOL, 4)
            oprot.writeBool(self.isOptionallyQuote)
            oprot.writeFieldEnd()
        if self.quote is not None:
            oprot.writeFieldBegin('quote', TType.I16, 5)
            oprot.writeI16(self.quote)
            oprot.writeFieldEnd()
        if self.escaped is not None:
            oprot.writeFieldBegin('escaped', TType.I16, 6)
            oprot.writeI16(self.escaped)
            oprot.writeFieldEnd()
        if self.recordSeparator is not None:
            oprot.writeFieldBegin('recordSeparator', TType.STRING, 7)
            oprot.writeString(self.recordSeparator.encode('utf-8') if sys.version_info[0] == 2 else self.recordSeparator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.exportCsvPath is None:
            raise TProtocolException(message='Required field exportCsvPath is unset!')
        if self.isExportHeader is None:
            raise TProtocolException(message='Required field isExportHeader is unset!')
        if self.delimiter is None:
            raise TProtocolException(message='Required field delimiter is unset!')
        if self.isOptionallyQuote is None:
            raise TProtocolException(message='Required field isOptionallyQuote is unset!')
        if self.quote is None:
            raise TProtocolException(message='Required field quote is unset!')
        if self.escaped is None:
            raise TProtocolException(message='Required field escaped is unset!')
        if self.recordSeparator is None:
            raise TProtocolException(message='Required field recordSeparator is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryDataSetV2(object):
    """
    Attributes:
     - valuesList
     - bitmapList

    """


    def __init__(self, valuesList=None, bitmapList=None,):
        self.valuesList = valuesList
        self.bitmapList = bitmapList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype736, _size733) = iprot.readListBegin()
                    for _i737 in range(_size733):
                        _elem738 = iprot.readBinary()
                        self.valuesList.append(_elem738)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype742, _size739) = iprot.readListBegin()
                    for _i743 in range(_size739):
                        _elem744 = iprot.readBinary()
                        self.bitmapList.append(_elem744)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryDataSetV2')
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter745 in self.valuesList:
                oprot.writeBinary(iter745)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter746 in self.bitmapList:
                oprot.writeBinary(iter746)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CloseStatementReq(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CloseStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FetchResultsReq(object):
    """
    Attributes:
     - sessionId
     - queryId
     - fetchSize
     - timeout

    """


    def __init__(self, sessionId=None, queryId=None, fetchSize=None, timeout=None,):
        self.sessionId = sessionId
        self.queryId = queryId
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchResultsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 4)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FetchResultsResp(object):
    """
    Attributes:
     - status
     - hasMoreResults
     - queryDataSet

    """


    def __init__(self, status=None, hasMoreResults=None, queryDataSet=None,):
        self.status = status
        self.hasMoreResults = hasMoreResults
        self.queryDataSet = queryDataSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hasMoreResults = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSetV2()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchResultsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.hasMoreResults is not None:
            oprot.writeFieldBegin('hasMoreResults', TType.BOOL, 2)
            oprot.writeBool(self.hasMoreResults)
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 3)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.hasMoreResults is None:
            raise TProtocolException(message='Required field hasMoreResults is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadCSVReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - csvFile

    """


    def __init__(self, sessionId=None, statement=None, csvFile=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.csvFile = csvFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.csvFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadCSVReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.csvFile is not None:
            oprot.writeFieldBegin('csvFile', TType.STRING, 3)
            oprot.writeBinary(self.csvFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.csvFile is None:
            raise TProtocolException(message='Required field csvFile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadCSVResp(object):
    """
    Attributes:
     - status
     - columns
     - recordsNum
     - parseErrorMsg

    """


    def __init__(self, status=None, columns=None, recordsNum=None, parseErrorMsg=None,):
        self.status = status
        self.columns = columns
        self.recordsNum = recordsNum
        self.parseErrorMsg = parseErrorMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype750, _size747) = iprot.readListBegin()
                    for _i751 in range(_size747):
                        _elem752 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem752)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.recordsNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.parseErrorMsg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadCSVResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter753 in self.columns:
                oprot.writeString(iter753.encode('utf-8') if sys.version_info[0] == 2 else iter753)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.recordsNum is not None:
            oprot.writeFieldBegin('recordsNum', TType.I64, 3)
            oprot.writeI64(self.recordsNum)
            oprot.writeFieldEnd()
        if self.parseErrorMsg is not None:
            oprot.writeFieldBegin('parseErrorMsg', TType.STRING, 4)
            oprot.writeString(self.parseErrorMsg.encode('utf-8') if sys.version_info[0] == 2 else self.parseErrorMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadUDFReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - udfFile
     - isRemote

    """


    def __init__(self, sessionId=None, statement=None, udfFile=None, isRemote=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.udfFile = udfFile
        self.isRemote = isRemote

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.udfFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isRemote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadUDFReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.udfFile is not None:
            oprot.writeFieldBegin('udfFile', TType.STRING, 3)
            oprot.writeBinary(self.udfFile)
            oprot.writeFieldEnd()
        if self.isRemote is not None:
            oprot.writeFieldBegin('isRemote', TType.BOOL, 4)
            oprot.writeBool(self.isRemote)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.isRemote is None:
            raise TProtocolException(message='Required field isRemote is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadUDFResp(object):
    """
    Attributes:
     - status
     - parseErrorMsg
     - UDFModulePath

    """


    def __init__(self, status=None, parseErrorMsg=None, UDFModulePath=None,):
        self.status = status
        self.parseErrorMsg = parseErrorMsg
        self.UDFModulePath = UDFModulePath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parseErrorMsg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.UDFModulePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadUDFResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.parseErrorMsg is not None:
            oprot.writeFieldBegin('parseErrorMsg', TType.STRING, 2)
            oprot.writeString(self.parseErrorMsg.encode('utf-8') if sys.version_info[0] == 2 else self.parseErrorMsg)
            oprot.writeFieldEnd()
        if self.UDFModulePath is not None:
            oprot.writeFieldBegin('UDFModulePath', TType.STRING, 3)
            oprot.writeString(self.UDFModulePath.encode('utf-8') if sys.version_info[0] == 2 else self.UDFModulePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TaskInfo(object):
    """
    Attributes:
     - taskType
     - dataFlowType
     - timeout
     - sqlList
     - pyTaskName

    """


    def __init__(self, taskType=None, dataFlowType=None, timeout=None, sqlList=None, pyTaskName=None,):
        self.taskType = taskType
        self.dataFlowType = dataFlowType
        self.timeout = timeout
        self.sqlList = sqlList
        self.pyTaskName = pyTaskName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.taskType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataFlowType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sqlList = []
                    (_etype757, _size754) = iprot.readListBegin()
                    for _i758 in range(_size754):
                        _elem759 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sqlList.append(_elem759)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pyTaskName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TaskInfo')
        if self.taskType is not None:
            oprot.writeFieldBegin('taskType', TType.I32, 1)
            oprot.writeI32(self.taskType)
            oprot.writeFieldEnd()
        if self.dataFlowType is not None:
            oprot.writeFieldBegin('dataFlowType', TType.I32, 2)
            oprot.writeI32(self.dataFlowType)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 3)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.sqlList is not None:
            oprot.writeFieldBegin('sqlList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.sqlList))
            for iter760 in self.sqlList:
                oprot.writeString(iter760.encode('utf-8') if sys.version_info[0] == 2 else iter760)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pyTaskName is not None:
            oprot.writeFieldBegin('pyTaskName', TType.STRING, 5)
            oprot.writeString(self.pyTaskName.encode('utf-8') if sys.version_info[0] == 2 else self.pyTaskName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.taskType is None:
            raise TProtocolException(message='Required field taskType is unset!')
        if self.dataFlowType is None:
            raise TProtocolException(message='Required field dataFlowType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommitTransformJobReq(object):
    """
    Attributes:
     - sessionId
     - taskList
     - exportType
     - fileName

    """


    def __init__(self, sessionId=None, taskList=None, exportType=None, fileName=None,):
        self.sessionId = sessionId
        self.taskList = taskList
        self.exportType = exportType
        self.fileName = fileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.taskList = []
                    (_etype764, _size761) = iprot.readListBegin()
                    for _i765 in range(_size761):
                        _elem766 = TaskInfo()
                        _elem766.read(iprot)
                        self.taskList.append(_elem766)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.exportType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitTransformJobReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.taskList is not None:
            oprot.writeFieldBegin('taskList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.taskList))
            for iter767 in self.taskList:
                iter767.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exportType is not None:
            oprot.writeFieldBegin('exportType', TType.I32, 3)
            oprot.writeI32(self.exportType)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 4)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.taskList is None:
            raise TProtocolException(message='Required field taskList is unset!')
        if self.exportType is None:
            raise TProtocolException(message='Required field exportType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommitTransformJobResp(object):
    """
    Attributes:
     - status
     - jobId

    """


    def __init__(self, status=None, jobId=None,):
        self.status = status
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitTransformJobResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 2)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jobId is None:
            raise TProtocolException(message='Required field jobId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryTransformJobStatusReq(object):
    """
    Attributes:
     - sessionId
     - jobId

    """


    def __init__(self, sessionId=None, jobId=None,):
        self.sessionId = sessionId
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryTransformJobStatusReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 2)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.jobId is None:
            raise TProtocolException(message='Required field jobId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryTransformJobStatusResp(object):
    """
    Attributes:
     - status
     - jobState

    """


    def __init__(self, status=None, jobState=None,):
        self.status = status
        self.jobState = jobState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.jobState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryTransformJobStatusResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jobState is not None:
            oprot.writeFieldBegin('jobState', TType.I32, 2)
            oprot.writeI32(self.jobState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jobState is None:
            raise TProtocolException(message='Required field jobState is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowEligibleJobReq(object):
    """
    Attributes:
     - sessionId
     - jobState

    """


    def __init__(self, sessionId=None, jobState=None,):
        self.sessionId = sessionId
        self.jobState = jobState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.jobState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowEligibleJobReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.jobState is not None:
            oprot.writeFieldBegin('jobState', TType.I32, 2)
            oprot.writeI32(self.jobState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.jobState is None:
            raise TProtocolException(message='Required field jobState is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowEligibleJobResp(object):
    """
    Attributes:
     - status
     - jobIdList

    """


    def __init__(self, status=None, jobIdList=None,):
        self.status = status
        self.jobIdList = jobIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.jobIdList = []
                    (_etype771, _size768) = iprot.readListBegin()
                    for _i772 in range(_size768):
                        _elem773 = iprot.readI64()
                        self.jobIdList.append(_elem773)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowEligibleJobResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jobIdList is not None:
            oprot.writeFieldBegin('jobIdList', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.jobIdList))
            for iter774 in self.jobIdList:
                oprot.writeI64(iter774)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jobIdList is None:
            raise TProtocolException(message='Required field jobIdList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CancelTransformJobReq(object):
    """
    Attributes:
     - sessionId
     - jobId

    """


    def __init__(self, sessionId=None, jobId=None,):
        self.sessionId = sessionId
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CancelTransformJobReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 2)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.jobId is None:
            raise TProtocolException(message='Required field jobId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RegisterTaskReq(object):
    """
    Attributes:
     - sessionId
     - filePath
     - UDFClassPairs
     - types
     - moduleFile
     - isRemote

    """


    def __init__(self, sessionId=None, filePath=None, UDFClassPairs=None, types=None, moduleFile=None, isRemote=None,):
        self.sessionId = sessionId
        self.filePath = filePath
        self.UDFClassPairs = UDFClassPairs
        self.types = types
        self.moduleFile = moduleFile
        self.isRemote = isRemote

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.UDFClassPairs = []
                    (_etype778, _size775) = iprot.readListBegin()
                    for _i779 in range(_size775):
                        _elem780 = UDFClassPair()
                        _elem780.read(iprot)
                        self.UDFClassPairs.append(_elem780)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.types = []
                    (_etype784, _size781) = iprot.readListBegin()
                    for _i785 in range(_size781):
                        _elem786 = iprot.readI32()
                        self.types.append(_elem786)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.moduleFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isRemote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RegisterTaskReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.filePath is not None:
            oprot.writeFieldBegin('filePath', TType.STRING, 2)
            oprot.writeString(self.filePath.encode('utf-8') if sys.version_info[0] == 2 else self.filePath)
            oprot.writeFieldEnd()
        if self.UDFClassPairs is not None:
            oprot.writeFieldBegin('UDFClassPairs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.UDFClassPairs))
            for iter787 in self.UDFClassPairs:
                iter787.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.types))
            for iter788 in self.types:
                oprot.writeI32(iter788)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.moduleFile is not None:
            oprot.writeFieldBegin('moduleFile', TType.STRING, 5)
            oprot.writeBinary(self.moduleFile)
            oprot.writeFieldEnd()
        if self.isRemote is not None:
            oprot.writeFieldBegin('isRemote', TType.BOOL, 6)
            oprot.writeBool(self.isRemote)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.filePath is None:
            raise TProtocolException(message='Required field filePath is unset!')
        if self.UDFClassPairs is None:
            raise TProtocolException(message='Required field UDFClassPairs is unset!')
        if self.types is None:
            raise TProtocolException(message='Required field types is unset!')
        if self.moduleFile is None:
            raise TProtocolException(message='Required field moduleFile is unset!')
        if self.isRemote is None:
            raise TProtocolException(message='Required field isRemote is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DropTaskReq(object):
    """
    Attributes:
     - sessionId
     - name

    """


    def __init__(self, sessionId=None, name=None,):
        self.sessionId = sessionId
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DropTaskReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRegisterTaskInfoReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRegisterTaskInfoReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RegisterTaskInfo(object):
    """
    Attributes:
     - name
     - className
     - fileName
     - ip
     - type

    """


    def __init__(self, name=None, className=None, fileName=None, ip=None, type=None,):
        self.name = name
        self.className = className
        self.fileName = fileName
        self.ip = ip
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RegisterTaskInfo')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 3)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 4)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 5)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.fileName is None:
            raise TProtocolException(message='Required field fileName is unset!')
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRegisterTaskInfoResp(object):
    """
    Attributes:
     - status
     - registerTaskInfoList

    """


    def __init__(self, status=None, registerTaskInfoList=None,):
        self.status = status
        self.registerTaskInfoList = registerTaskInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.registerTaskInfoList = []
                    (_etype792, _size789) = iprot.readListBegin()
                    for _i793 in range(_size789):
                        _elem794 = RegisterTaskInfo()
                        _elem794.read(iprot)
                        self.registerTaskInfoList.append(_elem794)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRegisterTaskInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.registerTaskInfoList is not None:
            oprot.writeFieldBegin('registerTaskInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.registerTaskInfoList))
            for iter795 in self.registerTaskInfoList:
                iter795.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CurveMatchReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - curveQuery
     - curveUnit

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, curveQuery=None, curveUnit=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.curveQuery = curveQuery
        self.curveUnit = curveUnit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype799, _size796) = iprot.readListBegin()
                    for _i800 in range(_size796):
                        _elem801 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem801)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.curveQuery = []
                    (_etype805, _size802) = iprot.readListBegin()
                    for _i806 in range(_size802):
                        _elem807 = iprot.readDouble()
                        self.curveQuery.append(_elem807)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.curveUnit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CurveMatchReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter808 in self.paths:
                oprot.writeString(iter808.encode('utf-8') if sys.version_info[0] == 2 else iter808)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.curveQuery is not None:
            oprot.writeFieldBegin('curveQuery', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.curveQuery))
            for iter809 in self.curveQuery:
                oprot.writeDouble(iter809)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.curveUnit is not None:
            oprot.writeFieldBegin('curveUnit', TType.I64, 6)
            oprot.writeI64(self.curveUnit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        if self.curveQuery is None:
            raise TProtocolException(message='Required field curveQuery is unset!')
        if self.curveUnit is None:
            raise TProtocolException(message='Required field curveUnit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CurveMatchResp(object):
    """
    Attributes:
     - status
     - matchedPath
     - matchedKey

    """


    def __init__(self, status=None, matchedPath=None, matchedKey=None,):
        self.status = status
        self.matchedPath = matchedPath
        self.matchedKey = matchedKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.matchedPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.matchedKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CurveMatchResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.matchedPath is not None:
            oprot.writeFieldBegin('matchedPath', TType.STRING, 2)
            oprot.writeString(self.matchedPath.encode('utf-8') if sys.version_info[0] == 2 else self.matchedPath)
            oprot.writeFieldEnd()
        if self.matchedKey is not None:
            oprot.writeFieldBegin('matchedKey', TType.I64, 3)
            oprot.writeI64(self.matchedKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetMetaReq(object):
    """
    Attributes:
     - byCache

    """


    def __init__(self, byCache=None,):
        self.byCache = byCache

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.byCache = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMetaReq')
        if self.byCache is not None:
            oprot.writeFieldBegin('byCache', TType.BOOL, 1)
            oprot.writeBool(self.byCache)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.byCache is None:
            raise TProtocolException(message='Required field byCache is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Fragment(object):
    """
    Attributes:
     - storageUnitId
     - startKey
     - endKey
     - startTs
     - endTs

    """


    def __init__(self, storageUnitId=None, startKey=None, endKey=None, startTs=None, endTs=None,):
        self.storageUnitId = storageUnitId
        self.startKey = startKey
        self.endKey = endKey
        self.startTs = startTs
        self.endTs = endTs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageUnitId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.startTs = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.endTs = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Fragment')
        if self.storageUnitId is not None:
            oprot.writeFieldBegin('storageUnitId', TType.STRING, 1)
            oprot.writeString(self.storageUnitId.encode('utf-8') if sys.version_info[0] == 2 else self.storageUnitId)
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 2)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 3)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.startTs is not None:
            oprot.writeFieldBegin('startTs', TType.STRING, 4)
            oprot.writeString(self.startTs.encode('utf-8') if sys.version_info[0] == 2 else self.startTs)
            oprot.writeFieldEnd()
        if self.endTs is not None:
            oprot.writeFieldBegin('endTs', TType.STRING, 5)
            oprot.writeString(self.endTs.encode('utf-8') if sys.version_info[0] == 2 else self.endTs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageUnitId is None:
            raise TProtocolException(message='Required field storageUnitId is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        if self.startTs is None:
            raise TProtocolException(message='Required field startTs is unset!')
        if self.endTs is None:
            raise TProtocolException(message='Required field endTs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Storage(object):
    """
    Attributes:
     - id
     - ip
     - port
     - type

    """


    def __init__(self, id=None, ip=None, port=None, type=None,):
        self.id = id
        self.ip = ip
        self.port = port
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.port = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Storage')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 2)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I64, 3)
            oprot.writeI64(self.port)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StorageUnit(object):
    """
    Attributes:
     - id
     - masterId
     - storageId

    """


    def __init__(self, id=None, masterId=None, storageId=None,):
        self.id = id
        self.masterId = masterId
        self.storageId = storageId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.masterId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.storageId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StorageUnit')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.masterId is not None:
            oprot.writeFieldBegin('masterId', TType.STRING, 2)
            oprot.writeString(self.masterId.encode('utf-8') if sys.version_info[0] == 2 else self.masterId)
            oprot.writeFieldEnd()
        if self.storageId is not None:
            oprot.writeFieldBegin('storageId', TType.I64, 3)
            oprot.writeI64(self.storageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.masterId is None:
            raise TProtocolException(message='Required field masterId is unset!')
        if self.storageId is None:
            raise TProtocolException(message='Required field storageId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetMetaResp(object):
    """
    Attributes:
     - fragments
     - storages
     - storageUnits

    """


    def __init__(self, fragments=None, storages=None, storageUnits=None,):
        self.fragments = fragments
        self.storages = storages
        self.storageUnits = storageUnits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fragments = []
                    (_etype813, _size810) = iprot.readListBegin()
                    for _i814 in range(_size810):
                        _elem815 = Fragment()
                        _elem815.read(iprot)
                        self.fragments.append(_elem815)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.storages = []
                    (_etype819, _size816) = iprot.readListBegin()
                    for _i820 in range(_size816):
                        _elem821 = Storage()
                        _elem821.read(iprot)
                        self.storages.append(_elem821)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.storageUnits = []
                    (_etype825, _size822) = iprot.readListBegin()
                    for _i826 in range(_size822):
                        _elem827 = StorageUnit()
                        _elem827.read(iprot)
                        self.storageUnits.append(_elem827)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMetaResp')
        if self.fragments is not None:
            oprot.writeFieldBegin('fragments', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.fragments))
            for iter828 in self.fragments:
                iter828.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storages is not None:
            oprot.writeFieldBegin('storages', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.storages))
            for iter829 in self.storages:
                iter829.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageUnits is not None:
            oprot.writeFieldBegin('storageUnits', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.storageUnits))
            for iter830 in self.storageUnits:
                iter830.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragments is None:
            raise TProtocolException(message='Required field fragments is unset!')
        if self.storages is None:
            raise TProtocolException(message='Required field storages is unset!')
        if self.storageUnits is None:
            raise TProtocolException(message='Required field storageUnits is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DebugInfoReq(object):
    """
    Attributes:
     - payloadType
     - payload

    """


    def __init__(self, payloadType=None, payload=None,):
        self.payloadType = payloadType
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.payloadType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DebugInfoReq')
        if self.payloadType is not None:
            oprot.writeFieldBegin('payloadType', TType.I32, 1)
            oprot.writeI32(self.payloadType)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 2)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.payloadType is None:
            raise TProtocolException(message='Required field payloadType is unset!')
        if self.payload is None:
            raise TProtocolException(message='Required field payload is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DebugInfoResp(object):
    """
    Attributes:
     - status
     - payload

    """


    def __init__(self, status=None, payload=None,):
        self.status = status
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DebugInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 2)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RemovedStorageEngineInfo(object):
    """
    Attributes:
     - ip
     - port
     - schemaPrefix
     - dataPrefix

    """


    def __init__(self, ip=None, port=None, schemaPrefix=None, dataPrefix=None,):
        self.ip = ip
        self.port = port
        self.schemaPrefix = schemaPrefix
        self.dataPrefix = dataPrefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.schemaPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dataPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemovedStorageEngineInfo')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.schemaPrefix is not None:
            oprot.writeFieldBegin('schemaPrefix', TType.STRING, 3)
            oprot.writeString(self.schemaPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.schemaPrefix)
            oprot.writeFieldEnd()
        if self.dataPrefix is not None:
            oprot.writeFieldBegin('dataPrefix', TType.STRING, 4)
            oprot.writeString(self.dataPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.dataPrefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.schemaPrefix is None:
            raise TProtocolException(message='Required field schemaPrefix is unset!')
        if self.dataPrefix is None:
            raise TProtocolException(message='Required field dataPrefix is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RemoveHistoryDataSourceReq(object):
    """
    Attributes:
     - sessionId
     - removedStorageEngineInfoList

    """


    def __init__(self, sessionId=None, removedStorageEngineInfoList=None,):
        self.sessionId = sessionId
        self.removedStorageEngineInfoList = removedStorageEngineInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.removedStorageEngineInfoList = []
                    (_etype834, _size831) = iprot.readListBegin()
                    for _i835 in range(_size831):
                        _elem836 = RemovedStorageEngineInfo()
                        _elem836.read(iprot)
                        self.removedStorageEngineInfoList.append(_elem836)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemoveHistoryDataSourceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.removedStorageEngineInfoList is not None:
            oprot.writeFieldBegin('removedStorageEngineInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.removedStorageEngineInfoList))
            for iter837 in self.removedStorageEngineInfoList:
                iter837.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.removedStorageEngineInfoList is None:
            raise TProtocolException(message='Required field removedStorageEngineInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowSessionIDReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowSessionIDReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowSessionIDResp(object):
    """
    Attributes:
     - status
     - sessionIDList

    """


    def __init__(self, status=None, sessionIDList=None,):
        self.status = status
        self.sessionIDList = sessionIDList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sessionIDList = []
                    (_etype841, _size838) = iprot.readListBegin()
                    for _i842 in range(_size838):
                        _elem843 = iprot.readI64()
                        self.sessionIDList.append(_elem843)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowSessionIDResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.sessionIDList is not None:
            oprot.writeFieldBegin('sessionIDList', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.sessionIDList))
            for iter844 in self.sessionIDList:
                oprot.writeI64(iter844)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.sessionIDList is None:
            raise TProtocolException(message='Required field sessionIDList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowRulesReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowRulesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowRulesResp(object):
    """
    Attributes:
     - status
     - rules

    """


    def __init__(self, status=None, rules=None,):
        self.status = status
        self.rules = rules

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.rules = {}
                    (_ktype846, _vtype847, _size845) = iprot.readMapBegin()
                    for _i849 in range(_size845):
                        _key850 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val851 = iprot.readBool()
                        self.rules[_key850] = _val851
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowRulesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.rules is not None:
            oprot.writeFieldBegin('rules', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.BOOL, len(self.rules))
            for kiter852, viter853 in self.rules.items():
                oprot.writeString(kiter852.encode('utf-8') if sys.version_info[0] == 2 else kiter852)
                oprot.writeBool(viter853)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.rules is None:
            raise TProtocolException(message='Required field rules is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetRulesReq(object):
    """
    Attributes:
     - sessionId
     - rulesChange

    """


    def __init__(self, sessionId=None, rulesChange=None,):
        self.sessionId = sessionId
        self.rulesChange = rulesChange

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.rulesChange = {}
                    (_ktype855, _vtype856, _size854) = iprot.readMapBegin()
                    for _i858 in range(_size854):
                        _key859 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val860 = iprot.readBool()
                        self.rulesChange[_key859] = _val860
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetRulesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.rulesChange is not None:
            oprot.writeFieldBegin('rulesChange', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.BOOL, len(self.rulesChange))
            for kiter861, viter862 in self.rulesChange.items():
                oprot.writeString(kiter861.encode('utf-8') if sys.version_info[0] == 2 else kiter861)
                oprot.writeBool(viter862)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.rulesChange is None:
            raise TProtocolException(message='Required field rulesChange is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Status)
Status.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'subStatus', (TType.STRUCT, [Status, None], False), None, ),  # 3
)
all_structs.append(UDFClassPair)
UDFClassPair.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'classPath', 'UTF8', None, ),  # 2
)
all_structs.append(OpenSessionReq)
OpenSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)
all_structs.append(OpenSessionResp)
OpenSessionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I64, 'sessionId', None, None, ),  # 2
)
all_structs.append(CloseSessionReq)
CloseSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(DeleteColumnsReq)
DeleteColumnsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 3
    (4, TType.I32, 'filterType', None, None, ),  # 4
)
all_structs.append(InsertColumnRecordsReq)
InsertColumnRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'keys', 'BINARY', None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
)
all_structs.append(InsertNonAlignedColumnRecordsReq)
InsertNonAlignedColumnRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'keys', 'BINARY', None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
)
all_structs.append(InsertRowRecordsReq)
InsertRowRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'keys', 'BINARY', None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
)
all_structs.append(InsertNonAlignedRowRecordsReq)
InsertNonAlignedRowRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'keys', 'BINARY', None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
)
all_structs.append(DeleteDataInColumnsReq)
DeleteDataInColumnsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 5
    (6, TType.I32, 'filterType', None, None, ),  # 6
    (7, TType.I32, 'timePrecision', None, None, ),  # 7
)
all_structs.append(QueryDataSet)
QueryDataSet.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'keys', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 3
)
all_structs.append(QueryDataReq)
QueryDataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 5
    (6, TType.I32, 'timePrecision', None, None, ),  # 6
    (7, TType.I32, 'filterType', None, None, ),  # 7
)
all_structs.append(QueryDataResp)
QueryDataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRUCT, 'queryDataSet', [QueryDataSet, None], None, ),  # 5
)
all_structs.append(AddStorageEnginesReq)
AddStorageEnginesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'storageEngines', (TType.STRUCT, [StorageEngine, None], False), None, ),  # 2
)
all_structs.append(StorageEngine)
StorageEngine.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
    (4, TType.MAP, 'extraParams', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(AggregateQueryReq)
AggregateQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.I32, 'aggregateType', None, None, ),  # 5
    (6, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 6
    (7, TType.I32, 'timePrecision', None, None, ),  # 7
    (8, TType.I32, 'filterType', None, None, ),  # 8
)
all_structs.append(AggregateQueryResp)
AggregateQueryResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRING, 'keys', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'valuesList', 'BINARY', None, ),  # 6
)
all_structs.append(LastQueryReq)
LastQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 4
    (5, TType.I32, 'timePrecision', None, None, ),  # 5
    (6, TType.I32, 'filterType', None, None, ),  # 6
)
all_structs.append(LastQueryResp)
LastQueryResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRUCT, 'queryDataSet', [QueryDataSet, None], None, ),  # 5
)
all_structs.append(DownsampleQueryReq)
DownsampleQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.I32, 'aggregateType', None, None, ),  # 5
    (6, TType.I64, 'precision', None, None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
    (9, TType.I32, 'filterType', None, None, ),  # 9
)
all_structs.append(DownsampleQueryResp)
DownsampleQueryResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRUCT, 'queryDataSet', [QueryDataSet, None], None, ),  # 5
)
all_structs.append(ShowColumnsReq)
ShowColumnsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(ShowColumnsResp)
ShowColumnsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(GetReplicaNumReq)
GetReplicaNumReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(GetReplicaNumResp)
GetReplicaNumResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I32, 'replicaNum', None, None, ),  # 2
)
all_structs.append(ExecuteSqlReq)
ExecuteSqlReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
)
all_structs.append(ExecuteSqlResp)
ExecuteSqlResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 5
    (6, TType.STRUCT, 'queryDataSet', [QueryDataSet, None], None, ),  # 6
    (7, TType.STRING, 'keys', 'BINARY', None, ),  # 7
    (8, TType.STRING, 'valuesList', 'BINARY', None, ),  # 8
    (9, TType.I32, 'replicaNum', None, None, ),  # 9
    (10, TType.I64, 'pointsNum', None, None, ),  # 10
    (11, TType.I32, 'aggregateType', None, None, ),  # 11
    (12, TType.STRING, 'parseErrorMsg', 'UTF8', None, ),  # 12
    (13, TType.I32, 'limit', None, None, ),  # 13
    (14, TType.I32, 'offset', None, None, ),  # 14
    (15, TType.STRING, 'orderByPath', 'UTF8', None, ),  # 15
    (16, TType.BOOL, 'ascending', None, None, ),  # 16
    (17, TType.LIST, 'iginxInfos', (TType.STRUCT, [IginxInfo, None], False), None, ),  # 17
    (18, TType.LIST, 'storageEngineInfos', (TType.STRUCT, [StorageEngineInfo, None], False), None, ),  # 18
    (19, TType.LIST, 'metaStorageInfos', (TType.STRUCT, [MetaStorageInfo, None], False), None, ),  # 19
    (20, TType.STRUCT, 'localMetaStorageInfo', [LocalMetaStorageInfo, None], None, ),  # 20
    (21, TType.LIST, 'registerTaskInfos', (TType.STRUCT, [RegisterTaskInfo, None], False), None, ),  # 21
    (22, TType.I64, 'jobId', None, None, ),  # 22
    (23, TType.I32, 'jobState', None, None, ),  # 23
    (24, TType.LIST, 'jobIdList', (TType.I64, None, False), None, ),  # 24
    (25, TType.MAP, 'configs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 25
    (26, TType.STRING, 'loadCsvPath', 'UTF8', None, ),  # 26
    (27, TType.LIST, 'sessionIDList', (TType.I64, None, False), None, ),  # 27
    (28, TType.MAP, 'rules', (TType.STRING, 'UTF8', TType.BOOL, None, False), None, ),  # 28
    (29, TType.STRING, 'UDFModulePath', 'UTF8', None, ),  # 29
)
all_structs.append(UpdateUserReq)
UpdateUserReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'password', 'UTF8', None, ),  # 3
    (4, TType.SET, 'auths', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(AddUserReq)
AddUserReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'password', 'UTF8', None, ),  # 3
    (4, TType.SET, 'auths', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(DeleteUserReq)
DeleteUserReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
)
all_structs.append(GetUserReq)
GetUserReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'usernames', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(GetUserResp)
GetUserResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'usernames', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'userTypes', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'auths', (TType.SET, (TType.I32, None, False), False), None, ),  # 4
)
all_structs.append(GetClusterInfoReq)
GetClusterInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(IginxInfo)
IginxInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'ip', 'UTF8', None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)
all_structs.append(StorageEngineInfo)
StorageEngineInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'ip', 'UTF8', None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
    (5, TType.STRING, 'schemaPrefix', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'dataPrefix', 'UTF8', None, ),  # 6
)
all_structs.append(MetaStorageInfo)
MetaStorageInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRING, 'type', 'UTF8', None, ),  # 3
)
all_structs.append(LocalMetaStorageInfo)
LocalMetaStorageInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'path', 'UTF8', None, ),  # 1
)
all_structs.append(GetClusterInfoResp)
GetClusterInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'iginxInfos', (TType.STRUCT, [IginxInfo, None], False), None, ),  # 2
    (3, TType.LIST, 'storageEngineInfos', (TType.STRUCT, [StorageEngineInfo, None], False), None, ),  # 3
    (4, TType.LIST, 'metaStorageInfos', (TType.STRUCT, [MetaStorageInfo, None], False), None, ),  # 4
    (5, TType.STRUCT, 'localMetaStorageInfo', [LocalMetaStorageInfo, None], None, ),  # 5
)
all_structs.append(ExecuteStatementReq)
ExecuteStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'timeout', None, None, ),  # 4
)
all_structs.append(ExecuteStatementResp)
ExecuteStatementResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.I64, 'queryId', None, None, ),  # 3
    (4, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.STRUCT, 'queryDataSet', [QueryDataSetV2, None], None, ),  # 7
    (8, TType.STRING, 'warningMsg', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'exportStreamDir', 'UTF8', None, ),  # 9
    (10, TType.STRUCT, 'exportCSV', [ExportCSV, None], None, ),  # 10
)
all_structs.append(ExportCSV)
ExportCSV.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'exportCsvPath', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'isExportHeader', None, None, ),  # 2
    (3, TType.STRING, 'delimiter', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isOptionallyQuote', None, None, ),  # 4
    (5, TType.I16, 'quote', None, None, ),  # 5
    (6, TType.I16, 'escaped', None, None, ),  # 6
    (7, TType.STRING, 'recordSeparator', 'UTF8', None, ),  # 7
)
all_structs.append(QueryDataSetV2)
QueryDataSetV2.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(CloseStatementReq)
CloseStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
)
all_structs.append(FetchResultsReq)
FetchResultsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'timeout', None, None, ),  # 4
)
all_structs.append(FetchResultsResp)
FetchResultsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.BOOL, 'hasMoreResults', None, None, ),  # 2
    (3, TType.STRUCT, 'queryDataSet', [QueryDataSetV2, None], None, ),  # 3
)
all_structs.append(LoadCSVReq)
LoadCSVReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'csvFile', 'BINARY', None, ),  # 3
)
all_structs.append(LoadCSVResp)
LoadCSVResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'recordsNum', None, None, ),  # 3
    (4, TType.STRING, 'parseErrorMsg', 'UTF8', None, ),  # 4
)
all_structs.append(LoadUDFReq)
LoadUDFReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'udfFile', 'BINARY', None, ),  # 3
    (4, TType.BOOL, 'isRemote', None, None, ),  # 4
)
all_structs.append(LoadUDFResp)
LoadUDFResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.STRING, 'parseErrorMsg', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'UDFModulePath', 'UTF8', None, ),  # 3
)
all_structs.append(TaskInfo)
TaskInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'taskType', None, None, ),  # 1
    (2, TType.I32, 'dataFlowType', None, None, ),  # 2
    (3, TType.I64, 'timeout', None, None, ),  # 3
    (4, TType.LIST, 'sqlList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'pyTaskName', 'UTF8', None, ),  # 5
)
all_structs.append(CommitTransformJobReq)
CommitTransformJobReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'taskList', (TType.STRUCT, [TaskInfo, None], False), None, ),  # 2
    (3, TType.I32, 'exportType', None, None, ),  # 3
    (4, TType.STRING, 'fileName', 'UTF8', None, ),  # 4
)
all_structs.append(CommitTransformJobResp)
CommitTransformJobResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I64, 'jobId', None, None, ),  # 2
)
all_structs.append(QueryTransformJobStatusReq)
QueryTransformJobStatusReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'jobId', None, None, ),  # 2
)
all_structs.append(QueryTransformJobStatusResp)
QueryTransformJobStatusResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I32, 'jobState', None, None, ),  # 2
)
all_structs.append(ShowEligibleJobReq)
ShowEligibleJobReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I32, 'jobState', None, None, ),  # 2
)
all_structs.append(ShowEligibleJobResp)
ShowEligibleJobResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'jobIdList', (TType.I64, None, False), None, ),  # 2
)
all_structs.append(CancelTransformJobReq)
CancelTransformJobReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'jobId', None, None, ),  # 2
)
all_structs.append(RegisterTaskReq)
RegisterTaskReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'filePath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'UDFClassPairs', (TType.STRUCT, [UDFClassPair, None], False), None, ),  # 3
    (4, TType.LIST, 'types', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRING, 'moduleFile', 'BINARY', None, ),  # 5
    (6, TType.BOOL, 'isRemote', None, None, ),  # 6
)
all_structs.append(DropTaskReq)
DropTaskReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)
all_structs.append(GetRegisterTaskInfoReq)
GetRegisterTaskInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(RegisterTaskInfo)
RegisterTaskInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'fileName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'ip', 'UTF8', None, ),  # 4
    (5, TType.I32, 'type', None, None, ),  # 5
)
all_structs.append(GetRegisterTaskInfoResp)
GetRegisterTaskInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'registerTaskInfoList', (TType.STRUCT, [RegisterTaskInfo, None], False), None, ),  # 2
)
all_structs.append(CurveMatchReq)
CurveMatchReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.LIST, 'curveQuery', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.I64, 'curveUnit', None, None, ),  # 6
)
all_structs.append(CurveMatchResp)
CurveMatchResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.STRING, 'matchedPath', 'UTF8', None, ),  # 2
    (3, TType.I64, 'matchedKey', None, None, ),  # 3
)
all_structs.append(GetMetaReq)
GetMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'byCache', None, None, ),  # 1
)
all_structs.append(Fragment)
Fragment.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storageUnitId', 'UTF8', None, ),  # 1
    (2, TType.I64, 'startKey', None, None, ),  # 2
    (3, TType.I64, 'endKey', None, None, ),  # 3
    (4, TType.STRING, 'startTs', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'endTs', 'UTF8', None, ),  # 5
)
all_structs.append(Storage)
Storage.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'ip', 'UTF8', None, ),  # 2
    (3, TType.I64, 'port', None, None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)
all_structs.append(StorageUnit)
StorageUnit.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'masterId', 'UTF8', None, ),  # 2
    (3, TType.I64, 'storageId', None, None, ),  # 3
)
all_structs.append(GetMetaResp)
GetMetaResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fragments', (TType.STRUCT, [Fragment, None], False), None, ),  # 1
    (2, TType.LIST, 'storages', (TType.STRUCT, [Storage, None], False), None, ),  # 2
    (3, TType.LIST, 'storageUnits', (TType.STRUCT, [StorageUnit, None], False), None, ),  # 3
)
all_structs.append(DebugInfoReq)
DebugInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'payloadType', None, None, ),  # 1
    (2, TType.STRING, 'payload', 'BINARY', None, ),  # 2
)
all_structs.append(DebugInfoResp)
DebugInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.STRING, 'payload', 'BINARY', None, ),  # 2
)
all_structs.append(RemovedStorageEngineInfo)
RemovedStorageEngineInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRING, 'schemaPrefix', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'dataPrefix', 'UTF8', None, ),  # 4
)
all_structs.append(RemoveHistoryDataSourceReq)
RemoveHistoryDataSourceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'removedStorageEngineInfoList', (TType.STRUCT, [RemovedStorageEngineInfo, None], False), None, ),  # 2
)
all_structs.append(ShowSessionIDReq)
ShowSessionIDReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(ShowSessionIDResp)
ShowSessionIDResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'sessionIDList', (TType.I64, None, False), None, ),  # 2
)
all_structs.append(ShowRulesReq)
ShowRulesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(ShowRulesResp)
ShowRulesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.MAP, 'rules', (TType.STRING, 'UTF8', TType.BOOL, None, False), None, ),  # 2
)
all_structs.append(SetRulesReq)
SetRulesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.MAP, 'rulesChange', (TType.STRING, 'UTF8', TType.BOOL, None, False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
