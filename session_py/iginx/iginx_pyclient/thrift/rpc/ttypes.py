#
# IGinX - the polystore system with high performance
# Copyright (C) Tsinghua University
# TSIGinX@gmail.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class DataType(object):
    BOOLEAN = 0
    INTEGER = 1
    LONG = 2
    FLOAT = 3
    DOUBLE = 4
    BINARY = 5

    _VALUES_TO_NAMES = {
        0: "BOOLEAN",
        1: "INTEGER",
        2: "LONG",
        3: "FLOAT",
        4: "DOUBLE",
        5: "BINARY",
    }

    _NAMES_TO_VALUES = {
        "BOOLEAN": 0,
        "INTEGER": 1,
        "LONG": 2,
        "FLOAT": 3,
        "DOUBLE": 4,
        "BINARY": 5,
    }


class StorageEngineType(object):
    unknown = 0
    iotdb12 = 1
    influxdb = 2
    filesystem = 3
    relational = 4
    mongodb = 5
    redis = 6

    _VALUES_TO_NAMES = {
        0: "unknown",
        1: "iotdb12",
        2: "influxdb",
        3: "filesystem",
        4: "relational",
        5: "mongodb",
        6: "redis",
    }

    _NAMES_TO_VALUES = {
        "unknown": 0,
        "iotdb12": 1,
        "influxdb": 2,
        "filesystem": 3,
        "relational": 4,
        "mongodb": 5,
        "redis": 6,
    }


class AggregateType(object):
    MAX = 0
    MIN = 1
    SUM = 2
    COUNT = 3
    AVG = 4
    FIRST_VALUE = 5
    LAST_VALUE = 6
    FIRST = 7
    LAST = 8

    _VALUES_TO_NAMES = {
        0: "MAX",
        1: "MIN",
        2: "SUM",
        3: "COUNT",
        4: "AVG",
        5: "FIRST_VALUE",
        6: "LAST_VALUE",
        7: "FIRST",
        8: "LAST",
    }

    _NAMES_TO_VALUES = {
        "MAX": 0,
        "MIN": 1,
        "SUM": 2,
        "COUNT": 3,
        "AVG": 4,
        "FIRST_VALUE": 5,
        "LAST_VALUE": 6,
        "FIRST": 7,
        "LAST": 8,
    }


class SqlType(object):
    Unknown = 0
    Insert = 1
    Delete = 2
    Query = 3
    GetReplicaNum = 4
    AddStorageEngines = 5
    AlterStorageEngine = 6
    CountPoints = 7
    ClearData = 8
    DeleteColumns = 9
    ShowColumns = 10
    ShowClusterInfo = 11
    ShowRegisterTask = 12
    RegisterTask = 13
    DropTask = 14
    CommitTransformJob = 15
    ShowJobStatus = 16
    CancelJob = 17
    ShowEligibleJob = 18
    RemoveStorageEngine = 19
    SetConfig = 20
    ShowConfig = 21
    Compact = 22
    ExportCsv = 23
    ExportStream = 24
    LoadCsv = 25
    ShowSessionID = 26
    ShowRules = 27
    SetRules = 28
    CreateUser = 29
    GrantUser = 30
    ChangeUserPassword = 31
    DropUser = 32
    ShowUser = 33

    _VALUES_TO_NAMES = {
        0: "Unknown",
        1: "Insert",
        2: "Delete",
        3: "Query",
        4: "GetReplicaNum",
        5: "AddStorageEngines",
        6: "AlterStorageEngine",
        7: "CountPoints",
        8: "ClearData",
        9: "DeleteColumns",
        10: "ShowColumns",
        11: "ShowClusterInfo",
        12: "ShowRegisterTask",
        13: "RegisterTask",
        14: "DropTask",
        15: "CommitTransformJob",
        16: "ShowJobStatus",
        17: "CancelJob",
        18: "ShowEligibleJob",
        19: "RemoveStorageEngine",
        20: "SetConfig",
        21: "ShowConfig",
        22: "Compact",
        23: "ExportCsv",
        24: "ExportStream",
        25: "LoadCsv",
        26: "ShowSessionID",
        27: "ShowRules",
        28: "SetRules",
        29: "CreateUser",
        30: "GrantUser",
        31: "ChangeUserPassword",
        32: "DropUser",
        33: "ShowUser",
    }

    _NAMES_TO_VALUES = {
        "Unknown": 0,
        "Insert": 1,
        "Delete": 2,
        "Query": 3,
        "GetReplicaNum": 4,
        "AddStorageEngines": 5,
        "AlterStorageEngine": 6,
        "CountPoints": 7,
        "ClearData": 8,
        "DeleteColumns": 9,
        "ShowColumns": 10,
        "ShowClusterInfo": 11,
        "ShowRegisterTask": 12,
        "RegisterTask": 13,
        "DropTask": 14,
        "CommitTransformJob": 15,
        "ShowJobStatus": 16,
        "CancelJob": 17,
        "ShowEligibleJob": 18,
        "RemoveStorageEngine": 19,
        "SetConfig": 20,
        "ShowConfig": 21,
        "Compact": 22,
        "ExportCsv": 23,
        "ExportStream": 24,
        "LoadCsv": 25,
        "ShowSessionID": 26,
        "ShowRules": 27,
        "SetRules": 28,
        "CreateUser": 29,
        "GrantUser": 30,
        "ChangeUserPassword": 31,
        "DropUser": 32,
        "ShowUser": 33,
    }


class AuthType(object):
    Read = 0
    Write = 1
    Admin = 2
    Cluster = 3

    _VALUES_TO_NAMES = {
        0: "Read",
        1: "Write",
        2: "Admin",
        3: "Cluster",
    }

    _NAMES_TO_VALUES = {
        "Read": 0,
        "Write": 1,
        "Admin": 2,
        "Cluster": 3,
    }


class UserType(object):
    Administrator = 0
    OrdinaryUser = 1

    _VALUES_TO_NAMES = {
        0: "Administrator",
        1: "OrdinaryUser",
    }

    _NAMES_TO_VALUES = {
        "Administrator": 0,
        "OrdinaryUser": 1,
    }


class ExportType(object):
    LOG = 0
    FILE = 1
    IGINX = 2

    _VALUES_TO_NAMES = {
        0: "LOG",
        1: "FILE",
        2: "IGINX",
    }

    _NAMES_TO_VALUES = {
        "LOG": 0,
        "FILE": 1,
        "IGINX": 2,
    }


class TaskType(object):
    IGINX = 0
    PYTHON = 1

    _VALUES_TO_NAMES = {
        0: "IGINX",
        1: "PYTHON",
    }

    _NAMES_TO_VALUES = {
        "IGINX": 0,
        "PYTHON": 1,
    }


class DataFlowType(object):
    BATCH = 0
    STREAM = 1

    _VALUES_TO_NAMES = {
        0: "BATCH",
        1: "STREAM",
    }

    _NAMES_TO_VALUES = {
        "BATCH": 0,
        "STREAM": 1,
    }


class JobState(object):
    JOB_UNKNOWN = 0
    JOB_FINISHED = 1
    JOB_CREATED = 2
    JOB_IDLE = 3
    JOB_RUNNING = 4
    JOB_PARTIALLY_FAILING = 5
    JOB_PARTIALLY_FAILED = 6
    JOB_FAILING = 7
    JOB_FAILED = 8
    JOB_CLOSING = 9
    JOB_CLOSED = 10

    _VALUES_TO_NAMES = {
        0: "JOB_UNKNOWN",
        1: "JOB_FINISHED",
        2: "JOB_CREATED",
        3: "JOB_IDLE",
        4: "JOB_RUNNING",
        5: "JOB_PARTIALLY_FAILING",
        6: "JOB_PARTIALLY_FAILED",
        7: "JOB_FAILING",
        8: "JOB_FAILED",
        9: "JOB_CLOSING",
        10: "JOB_CLOSED",
    }

    _NAMES_TO_VALUES = {
        "JOB_UNKNOWN": 0,
        "JOB_FINISHED": 1,
        "JOB_CREATED": 2,
        "JOB_IDLE": 3,
        "JOB_RUNNING": 4,
        "JOB_PARTIALLY_FAILING": 5,
        "JOB_PARTIALLY_FAILED": 6,
        "JOB_FAILING": 7,
        "JOB_FAILED": 8,
        "JOB_CLOSING": 9,
        "JOB_CLOSED": 10,
    }


class UDFType(object):
    UDAF = 0
    UDTF = 1
    UDSF = 2
    TRANSFORM = 3

    _VALUES_TO_NAMES = {
        0: "UDAF",
        1: "UDTF",
        2: "UDSF",
        3: "TRANSFORM",
    }

    _NAMES_TO_VALUES = {
        "UDAF": 0,
        "UDTF": 1,
        "UDSF": 2,
        "TRANSFORM": 3,
    }


class TimePrecision(object):
    YEAR = 0
    MONTH = 1
    WEEK = 2
    DAY = 3
    HOUR = 4
    MIN = 5
    S = 6
    MS = 7
    US = 8
    NS = 9

    _VALUES_TO_NAMES = {
        0: "YEAR",
        1: "MONTH",
        2: "WEEK",
        3: "DAY",
        4: "HOUR",
        5: "MIN",
        6: "S",
        7: "MS",
        8: "US",
        9: "NS",
    }

    _NAMES_TO_VALUES = {
        "YEAR": 0,
        "MONTH": 1,
        "WEEK": 2,
        "DAY": 3,
        "HOUR": 4,
        "MIN": 5,
        "S": 6,
        "MS": 7,
        "US": 8,
        "NS": 9,
    }


class TagFilterType(object):
    Base = 0
    And = 1
    Or = 2
    BasePrecise = 3
    Precise = 4
    WithoutTag = 5

    _VALUES_TO_NAMES = {
        0: "Base",
        1: "And",
        2: "Or",
        3: "BasePrecise",
        4: "Precise",
        5: "WithoutTag",
    }

    _NAMES_TO_VALUES = {
        "Base": 0,
        "And": 1,
        "Or": 2,
        "BasePrecise": 3,
        "Precise": 4,
        "WithoutTag": 5,
    }


class DebugInfoType(object):
    GET_META = 0

    _VALUES_TO_NAMES = {
        0: "GET_META",
    }

    _NAMES_TO_VALUES = {
        "GET_META": 0,
    }


class Status(object):
    """
    Attributes:
     - code
     - message
     - subStatus

    """


    def __init__(self, code=None, message=None, subStatus=None,):
        self.code = code
        self.message = message
        self.subStatus = subStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.subStatus = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = Status()
                        _elem5.read(iprot)
                        self.subStatus.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Status')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.subStatus is not None:
            oprot.writeFieldBegin('subStatus', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.subStatus))
            for iter6 in self.subStatus:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.code is None:
            raise TProtocolException(message='Required field code is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UDFClassPair(object):
    """
    Attributes:
     - name
     - classPath

    """


    def __init__(self, name=None, classPath=None,):
        self.name = name
        self.classPath = classPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.classPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UDFClassPair')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.classPath is not None:
            oprot.writeFieldBegin('classPath', TType.STRING, 2)
            oprot.writeString(self.classPath.encode('utf-8') if sys.version_info[0] == 2 else self.classPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.classPath is None:
            raise TProtocolException(message='Required field classPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OpenSessionReq(object):
    """
    Attributes:
     - username
     - password

    """


    def __init__(self, username=None, password=None,):
        self.username = username
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OpenSessionReq')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OpenSessionResp(object):
    """
    Attributes:
     - status
     - sessionId

    """


    def __init__(self, status=None, sessionId=None,):
        self.status = status
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OpenSessionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 2)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CloseSessionReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CloseSessionReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeleteColumnsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - tagsList
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, tagsList=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.tagsList = tagsList
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = {}
                        (_ktype20, _vtype21, _size19) = iprot.readMapBegin()
                        for _i23 in range(_size19):
                            _key24 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val25 = []
                            (_etype29, _size26) = iprot.readListBegin()
                            for _i30 in range(_size26):
                                _elem31 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val25.append(_elem31)
                            iprot.readListEnd()
                            _elem18[_key24] = _val25
                        iprot.readMapEnd()
                        self.tagsList.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteColumnsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter32 in self.paths:
                oprot.writeString(iter32.encode('utf-8') if sys.version_info[0] == 2 else iter32)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter33 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter33))
                for kiter34, viter35 in iter33.items():
                    oprot.writeString(kiter34.encode('utf-8') if sys.version_info[0] == 2 else kiter34)
                    oprot.writeListBegin(TType.STRING, len(viter35))
                    for iter36 in viter35:
                        oprot.writeString(iter36.encode('utf-8') if sys.version_info[0] == 2 else iter36)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 4)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertColumnRecordsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - keys
     - valuesList
     - bitmapList
     - dataTypeList
     - tagsList
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, keys=None, valuesList=None, bitmapList=None, dataTypeList=None, tagsList=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList
        self.dataTypeList = dataTypeList
        self.tagsList = tagsList
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype46, _size43) = iprot.readListBegin()
                    for _i47 in range(_size43):
                        _elem48 = iprot.readBinary()
                        self.valuesList.append(_elem48)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readBinary()
                        self.bitmapList.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readI32()
                        self.dataTypeList.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = {}
                        (_ktype68, _vtype69, _size67) = iprot.readMapBegin()
                        for _i71 in range(_size67):
                            _key72 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val73 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem66[_key72] = _val73
                        iprot.readMapEnd()
                        self.tagsList.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertColumnRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter74 in self.paths:
                oprot.writeString(iter74.encode('utf-8') if sys.version_info[0] == 2 else iter74)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 3)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter75 in self.valuesList:
                oprot.writeBinary(iter75)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter76 in self.bitmapList:
                oprot.writeBinary(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter77 in self.dataTypeList:
                oprot.writeI32(iter77)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter78 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter78))
                for kiter79, viter80 in iter78.items():
                    oprot.writeString(kiter79.encode('utf-8') if sys.version_info[0] == 2 else kiter79)
                    oprot.writeString(viter80.encode('utf-8') if sys.version_info[0] == 2 else viter80)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        if self.dataTypeList is None:
            raise TProtocolException(message='Required field dataTypeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertNonAlignedColumnRecordsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - keys
     - valuesList
     - bitmapList
     - dataTypeList
     - tagsList
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, keys=None, valuesList=None, bitmapList=None, dataTypeList=None, tagsList=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList
        self.dataTypeList = dataTypeList
        self.tagsList = tagsList
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype90, _size87) = iprot.readListBegin()
                    for _i91 in range(_size87):
                        _elem92 = iprot.readBinary()
                        self.valuesList.append(_elem92)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype96, _size93) = iprot.readListBegin()
                    for _i97 in range(_size93):
                        _elem98 = iprot.readBinary()
                        self.bitmapList.append(_elem98)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype102, _size99) = iprot.readListBegin()
                    for _i103 in range(_size99):
                        _elem104 = iprot.readI32()
                        self.dataTypeList.append(_elem104)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = {}
                        (_ktype112, _vtype113, _size111) = iprot.readMapBegin()
                        for _i115 in range(_size111):
                            _key116 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val117 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem110[_key116] = _val117
                        iprot.readMapEnd()
                        self.tagsList.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertNonAlignedColumnRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter118 in self.paths:
                oprot.writeString(iter118.encode('utf-8') if sys.version_info[0] == 2 else iter118)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 3)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter119 in self.valuesList:
                oprot.writeBinary(iter119)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter120 in self.bitmapList:
                oprot.writeBinary(iter120)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter121 in self.dataTypeList:
                oprot.writeI32(iter121)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter122 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter122))
                for kiter123, viter124 in iter122.items():
                    oprot.writeString(kiter123.encode('utf-8') if sys.version_info[0] == 2 else kiter123)
                    oprot.writeString(viter124.encode('utf-8') if sys.version_info[0] == 2 else viter124)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        if self.dataTypeList is None:
            raise TProtocolException(message='Required field dataTypeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertRowRecordsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - keys
     - valuesList
     - bitmapList
     - dataTypeList
     - tagsList
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, keys=None, valuesList=None, bitmapList=None, dataTypeList=None, tagsList=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList
        self.dataTypeList = dataTypeList
        self.tagsList = tagsList
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype134, _size131) = iprot.readListBegin()
                    for _i135 in range(_size131):
                        _elem136 = iprot.readBinary()
                        self.valuesList.append(_elem136)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype140, _size137) = iprot.readListBegin()
                    for _i141 in range(_size137):
                        _elem142 = iprot.readBinary()
                        self.bitmapList.append(_elem142)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype146, _size143) = iprot.readListBegin()
                    for _i147 in range(_size143):
                        _elem148 = iprot.readI32()
                        self.dataTypeList.append(_elem148)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = {}
                        (_ktype156, _vtype157, _size155) = iprot.readMapBegin()
                        for _i159 in range(_size155):
                            _key160 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val161 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem154[_key160] = _val161
                        iprot.readMapEnd()
                        self.tagsList.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertRowRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter162 in self.paths:
                oprot.writeString(iter162.encode('utf-8') if sys.version_info[0] == 2 else iter162)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 3)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter163 in self.valuesList:
                oprot.writeBinary(iter163)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter164 in self.bitmapList:
                oprot.writeBinary(iter164)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter165 in self.dataTypeList:
                oprot.writeI32(iter165)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter166 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter166))
                for kiter167, viter168 in iter166.items():
                    oprot.writeString(kiter167.encode('utf-8') if sys.version_info[0] == 2 else kiter167)
                    oprot.writeString(viter168.encode('utf-8') if sys.version_info[0] == 2 else viter168)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        if self.dataTypeList is None:
            raise TProtocolException(message='Required field dataTypeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertNonAlignedRowRecordsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - keys
     - valuesList
     - bitmapList
     - dataTypeList
     - tagsList
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, keys=None, valuesList=None, bitmapList=None, dataTypeList=None, tagsList=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList
        self.dataTypeList = dataTypeList
        self.tagsList = tagsList
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype172, _size169) = iprot.readListBegin()
                    for _i173 in range(_size169):
                        _elem174 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem174)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype178, _size175) = iprot.readListBegin()
                    for _i179 in range(_size175):
                        _elem180 = iprot.readBinary()
                        self.valuesList.append(_elem180)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype184, _size181) = iprot.readListBegin()
                    for _i185 in range(_size181):
                        _elem186 = iprot.readBinary()
                        self.bitmapList.append(_elem186)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype190, _size187) = iprot.readListBegin()
                    for _i191 in range(_size187):
                        _elem192 = iprot.readI32()
                        self.dataTypeList.append(_elem192)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype196, _size193) = iprot.readListBegin()
                    for _i197 in range(_size193):
                        _elem198 = {}
                        (_ktype200, _vtype201, _size199) = iprot.readMapBegin()
                        for _i203 in range(_size199):
                            _key204 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val205 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem198[_key204] = _val205
                        iprot.readMapEnd()
                        self.tagsList.append(_elem198)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertNonAlignedRowRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter206 in self.paths:
                oprot.writeString(iter206.encode('utf-8') if sys.version_info[0] == 2 else iter206)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 3)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter207 in self.valuesList:
                oprot.writeBinary(iter207)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter208 in self.bitmapList:
                oprot.writeBinary(iter208)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter209 in self.dataTypeList:
                oprot.writeI32(iter209)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter210 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter210))
                for kiter211, viter212 in iter210.items():
                    oprot.writeString(kiter211.encode('utf-8') if sys.version_info[0] == 2 else kiter211)
                    oprot.writeString(viter212.encode('utf-8') if sys.version_info[0] == 2 else viter212)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        if self.dataTypeList is None:
            raise TProtocolException(message='Required field dataTypeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeleteDataInColumnsReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - tagsList
     - filterType
     - timePrecision

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, tagsList=None, filterType=None, timePrecision=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.tagsList = tagsList
        self.filterType = filterType
        self.timePrecision = timePrecision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype216, _size213) = iprot.readListBegin()
                    for _i217 in range(_size213):
                        _elem218 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem218)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype222, _size219) = iprot.readListBegin()
                    for _i223 in range(_size219):
                        _elem224 = {}
                        (_ktype226, _vtype227, _size225) = iprot.readMapBegin()
                        for _i229 in range(_size225):
                            _key230 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val231 = []
                            (_etype235, _size232) = iprot.readListBegin()
                            for _i236 in range(_size232):
                                _elem237 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val231.append(_elem237)
                            iprot.readListEnd()
                            _elem224[_key230] = _val231
                        iprot.readMapEnd()
                        self.tagsList.append(_elem224)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteDataInColumnsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter238 in self.paths:
                oprot.writeString(iter238.encode('utf-8') if sys.version_info[0] == 2 else iter238)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 5)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter239 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter239))
                for kiter240, viter241 in iter239.items():
                    oprot.writeString(kiter240.encode('utf-8') if sys.version_info[0] == 2 else kiter240)
                    oprot.writeListBegin(TType.STRING, len(viter241))
                    for iter242 in viter241:
                        oprot.writeString(iter242.encode('utf-8') if sys.version_info[0] == 2 else iter242)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 6)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 7)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryDataSet(object):
    """
    Attributes:
     - keys
     - valuesList
     - bitmapList

    """


    def __init__(self, keys=None, valuesList=None, bitmapList=None,):
        self.keys = keys
        self.valuesList = valuesList
        self.bitmapList = bitmapList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype246, _size243) = iprot.readListBegin()
                    for _i247 in range(_size243):
                        _elem248 = iprot.readBinary()
                        self.valuesList.append(_elem248)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype252, _size249) = iprot.readListBegin()
                    for _i253 in range(_size249):
                        _elem254 = iprot.readBinary()
                        self.bitmapList.append(_elem254)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryDataSet')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 1)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter255 in self.valuesList:
                oprot.writeBinary(iter255)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter256 in self.bitmapList:
                oprot.writeBinary(iter256)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryDataReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - tagsList
     - timePrecision
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, tagsList=None, timePrecision=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.tagsList = tagsList
        self.timePrecision = timePrecision
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype260, _size257) = iprot.readListBegin()
                    for _i261 in range(_size257):
                        _elem262 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem262)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = {}
                        (_ktype270, _vtype271, _size269) = iprot.readMapBegin()
                        for _i273 in range(_size269):
                            _key274 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val275 = []
                            (_etype279, _size276) = iprot.readListBegin()
                            for _i280 in range(_size276):
                                _elem281 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val275.append(_elem281)
                            iprot.readListEnd()
                            _elem268[_key274] = _val275
                        iprot.readMapEnd()
                        self.tagsList.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryDataReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter282 in self.paths:
                oprot.writeString(iter282.encode('utf-8') if sys.version_info[0] == 2 else iter282)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 5)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter283 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter283))
                for kiter284, viter285 in iter283.items():
                    oprot.writeString(kiter284.encode('utf-8') if sys.version_info[0] == 2 else kiter284)
                    oprot.writeListBegin(TType.STRING, len(viter285))
                    for iter286 in viter285:
                        oprot.writeString(iter286.encode('utf-8') if sys.version_info[0] == 2 else iter286)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 6)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 7)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryDataResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList
     - queryDataSet

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None, queryDataSet=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype290, _size287) = iprot.readListBegin()
                    for _i291 in range(_size287):
                        _elem292 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem292)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype296, _size293) = iprot.readListBegin()
                    for _i297 in range(_size293):
                        _elem298 = {}
                        (_ktype300, _vtype301, _size299) = iprot.readMapBegin()
                        for _i303 in range(_size299):
                            _key304 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val305 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem298[_key304] = _val305
                        iprot.readMapEnd()
                        self.tagsList.append(_elem298)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype309, _size306) = iprot.readListBegin()
                    for _i310 in range(_size306):
                        _elem311 = iprot.readI32()
                        self.dataTypeList.append(_elem311)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryDataResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter312 in self.paths:
                oprot.writeString(iter312.encode('utf-8') if sys.version_info[0] == 2 else iter312)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter313 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter313))
                for kiter314, viter315 in iter313.items():
                    oprot.writeString(kiter314.encode('utf-8') if sys.version_info[0] == 2 else kiter314)
                    oprot.writeString(viter315.encode('utf-8') if sys.version_info[0] == 2 else viter315)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter316 in self.dataTypeList:
                oprot.writeI32(iter316)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 5)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddStorageEnginesReq(object):
    """
    Attributes:
     - sessionId
     - storageEngines

    """


    def __init__(self, sessionId=None, storageEngines=None,):
        self.sessionId = sessionId
        self.storageEngines = storageEngines

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.storageEngines = []
                    (_etype320, _size317) = iprot.readListBegin()
                    for _i321 in range(_size317):
                        _elem322 = StorageEngine()
                        _elem322.read(iprot)
                        self.storageEngines.append(_elem322)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddStorageEnginesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.storageEngines is not None:
            oprot.writeFieldBegin('storageEngines', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.storageEngines))
            for iter323 in self.storageEngines:
                iter323.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.storageEngines is None:
            raise TProtocolException(message='Required field storageEngines is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlterStorageEngineReq(object):
    """
    Attributes:
     - sessionId
     - engineId
     - newParams

    """


    def __init__(self, sessionId=None, engineId=None, newParams=None,):
        self.sessionId = sessionId
        self.engineId = engineId
        self.newParams = newParams

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.engineId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.newParams = {}
                    (_ktype325, _vtype326, _size324) = iprot.readMapBegin()
                    for _i328 in range(_size324):
                        _key329 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val330 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.newParams[_key329] = _val330
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlterStorageEngineReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.engineId is not None:
            oprot.writeFieldBegin('engineId', TType.I64, 2)
            oprot.writeI64(self.engineId)
            oprot.writeFieldEnd()
        if self.newParams is not None:
            oprot.writeFieldBegin('newParams', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.newParams))
            for kiter331, viter332 in self.newParams.items():
                oprot.writeString(kiter331.encode('utf-8') if sys.version_info[0] == 2 else kiter331)
                oprot.writeString(viter332.encode('utf-8') if sys.version_info[0] == 2 else viter332)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.engineId is None:
            raise TProtocolException(message='Required field engineId is unset!')
        if self.newParams is None:
            raise TProtocolException(message='Required field newParams is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StorageEngine(object):
    """
    Attributes:
     - ip
     - port
     - type
     - extraParams

    """


    def __init__(self, ip=None, port=None, type=None, extraParams=None,):
        self.ip = ip
        self.port = port
        self.type = type
        self.extraParams = extraParams

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.extraParams = {}
                    (_ktype334, _vtype335, _size333) = iprot.readMapBegin()
                    for _i337 in range(_size333):
                        _key338 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val339 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.extraParams[_key338] = _val339
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StorageEngine')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.extraParams is not None:
            oprot.writeFieldBegin('extraParams', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraParams))
            for kiter340, viter341 in self.extraParams.items():
                oprot.writeString(kiter340.encode('utf-8') if sys.version_info[0] == 2 else kiter340)
                oprot.writeString(viter341.encode('utf-8') if sys.version_info[0] == 2 else viter341)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.extraParams is None:
            raise TProtocolException(message='Required field extraParams is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggregateQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - aggregateType
     - tagsList
     - timePrecision
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, aggregateType=None, tagsList=None, timePrecision=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.aggregateType = aggregateType
        self.tagsList = tagsList
        self.timePrecision = timePrecision
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype345, _size342) = iprot.readListBegin()
                    for _i346 in range(_size342):
                        _elem347 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem347)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.aggregateType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype351, _size348) = iprot.readListBegin()
                    for _i352 in range(_size348):
                        _elem353 = {}
                        (_ktype355, _vtype356, _size354) = iprot.readMapBegin()
                        for _i358 in range(_size354):
                            _key359 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val360 = []
                            (_etype364, _size361) = iprot.readListBegin()
                            for _i365 in range(_size361):
                                _elem366 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val360.append(_elem366)
                            iprot.readListEnd()
                            _elem353[_key359] = _val360
                        iprot.readMapEnd()
                        self.tagsList.append(_elem353)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggregateQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter367 in self.paths:
                oprot.writeString(iter367.encode('utf-8') if sys.version_info[0] == 2 else iter367)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.aggregateType is not None:
            oprot.writeFieldBegin('aggregateType', TType.I32, 5)
            oprot.writeI32(self.aggregateType)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 6)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter368 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter368))
                for kiter369, viter370 in iter368.items():
                    oprot.writeString(kiter369.encode('utf-8') if sys.version_info[0] == 2 else kiter369)
                    oprot.writeListBegin(TType.STRING, len(viter370))
                    for iter371 in viter370:
                        oprot.writeString(iter371.encode('utf-8') if sys.version_info[0] == 2 else iter371)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 7)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 8)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        if self.aggregateType is None:
            raise TProtocolException(message='Required field aggregateType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggregateQueryResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList
     - keys
     - valuesList

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None, keys=None, valuesList=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.keys = keys
        self.valuesList = valuesList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype375, _size372) = iprot.readListBegin()
                    for _i376 in range(_size372):
                        _elem377 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem377)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype381, _size378) = iprot.readListBegin()
                    for _i382 in range(_size378):
                        _elem383 = {}
                        (_ktype385, _vtype386, _size384) = iprot.readMapBegin()
                        for _i388 in range(_size384):
                            _key389 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val390 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem383[_key389] = _val390
                        iprot.readMapEnd()
                        self.tagsList.append(_elem383)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype394, _size391) = iprot.readListBegin()
                    for _i395 in range(_size391):
                        _elem396 = iprot.readI32()
                        self.dataTypeList.append(_elem396)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.valuesList = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggregateQueryResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter397 in self.paths:
                oprot.writeString(iter397.encode('utf-8') if sys.version_info[0] == 2 else iter397)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter398 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter398))
                for kiter399, viter400 in iter398.items():
                    oprot.writeString(kiter399.encode('utf-8') if sys.version_info[0] == 2 else kiter399)
                    oprot.writeString(viter400.encode('utf-8') if sys.version_info[0] == 2 else viter400)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter401 in self.dataTypeList:
                oprot.writeI32(iter401)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 5)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.STRING, 6)
            oprot.writeBinary(self.valuesList)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LastQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - tagsList
     - timePrecision
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, tagsList=None, timePrecision=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.tagsList = tagsList
        self.timePrecision = timePrecision
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype405, _size402) = iprot.readListBegin()
                    for _i406 in range(_size402):
                        _elem407 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem407)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype411, _size408) = iprot.readListBegin()
                    for _i412 in range(_size408):
                        _elem413 = {}
                        (_ktype415, _vtype416, _size414) = iprot.readMapBegin()
                        for _i418 in range(_size414):
                            _key419 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val420 = []
                            (_etype424, _size421) = iprot.readListBegin()
                            for _i425 in range(_size421):
                                _elem426 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val420.append(_elem426)
                            iprot.readListEnd()
                            _elem413[_key419] = _val420
                        iprot.readMapEnd()
                        self.tagsList.append(_elem413)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LastQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter427 in self.paths:
                oprot.writeString(iter427.encode('utf-8') if sys.version_info[0] == 2 else iter427)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 4)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter428 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter428))
                for kiter429, viter430 in iter428.items():
                    oprot.writeString(kiter429.encode('utf-8') if sys.version_info[0] == 2 else kiter429)
                    oprot.writeListBegin(TType.STRING, len(viter430))
                    for iter431 in viter430:
                        oprot.writeString(iter431.encode('utf-8') if sys.version_info[0] == 2 else iter431)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 5)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 6)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LastQueryResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList
     - queryDataSet

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None, queryDataSet=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype435, _size432) = iprot.readListBegin()
                    for _i436 in range(_size432):
                        _elem437 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem437)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype441, _size438) = iprot.readListBegin()
                    for _i442 in range(_size438):
                        _elem443 = {}
                        (_ktype445, _vtype446, _size444) = iprot.readMapBegin()
                        for _i448 in range(_size444):
                            _key449 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val450 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem443[_key449] = _val450
                        iprot.readMapEnd()
                        self.tagsList.append(_elem443)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype454, _size451) = iprot.readListBegin()
                    for _i455 in range(_size451):
                        _elem456 = iprot.readI32()
                        self.dataTypeList.append(_elem456)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LastQueryResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter457 in self.paths:
                oprot.writeString(iter457.encode('utf-8') if sys.version_info[0] == 2 else iter457)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter458 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter458))
                for kiter459, viter460 in iter458.items():
                    oprot.writeString(kiter459.encode('utf-8') if sys.version_info[0] == 2 else kiter459)
                    oprot.writeString(viter460.encode('utf-8') if sys.version_info[0] == 2 else viter460)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter461 in self.dataTypeList:
                oprot.writeI32(iter461)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 5)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DownsampleQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - aggregateType
     - precision
     - tagsList
     - timePrecision
     - filterType

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, aggregateType=None, precision=None, tagsList=None, timePrecision=None, filterType=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.aggregateType = aggregateType
        self.precision = precision
        self.tagsList = tagsList
        self.timePrecision = timePrecision
        self.filterType = filterType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype465, _size462) = iprot.readListBegin()
                    for _i466 in range(_size462):
                        _elem467 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem467)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.aggregateType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.precision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype471, _size468) = iprot.readListBegin()
                    for _i472 in range(_size468):
                        _elem473 = {}
                        (_ktype475, _vtype476, _size474) = iprot.readMapBegin()
                        for _i478 in range(_size474):
                            _key479 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val480 = []
                            (_etype484, _size481) = iprot.readListBegin()
                            for _i485 in range(_size481):
                                _elem486 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val480.append(_elem486)
                            iprot.readListEnd()
                            _elem473[_key479] = _val480
                        iprot.readMapEnd()
                        self.tagsList.append(_elem473)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.timePrecision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.filterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DownsampleQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter487 in self.paths:
                oprot.writeString(iter487.encode('utf-8') if sys.version_info[0] == 2 else iter487)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.aggregateType is not None:
            oprot.writeFieldBegin('aggregateType', TType.I32, 5)
            oprot.writeI32(self.aggregateType)
            oprot.writeFieldEnd()
        if self.precision is not None:
            oprot.writeFieldBegin('precision', TType.I64, 6)
            oprot.writeI64(self.precision)
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter488 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.LIST, len(iter488))
                for kiter489, viter490 in iter488.items():
                    oprot.writeString(kiter489.encode('utf-8') if sys.version_info[0] == 2 else kiter489)
                    oprot.writeListBegin(TType.STRING, len(viter490))
                    for iter491 in viter490:
                        oprot.writeString(iter491.encode('utf-8') if sys.version_info[0] == 2 else iter491)
                    oprot.writeListEnd()
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePrecision is not None:
            oprot.writeFieldBegin('timePrecision', TType.I32, 8)
            oprot.writeI32(self.timePrecision)
            oprot.writeFieldEnd()
        if self.filterType is not None:
            oprot.writeFieldBegin('filterType', TType.I32, 9)
            oprot.writeI32(self.filterType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        if self.aggregateType is None:
            raise TProtocolException(message='Required field aggregateType is unset!')
        if self.precision is None:
            raise TProtocolException(message='Required field precision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DownsampleQueryResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList
     - queryDataSet

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None, queryDataSet=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype495, _size492) = iprot.readListBegin()
                    for _i496 in range(_size492):
                        _elem497 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem497)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype501, _size498) = iprot.readListBegin()
                    for _i502 in range(_size498):
                        _elem503 = {}
                        (_ktype505, _vtype506, _size504) = iprot.readMapBegin()
                        for _i508 in range(_size504):
                            _key509 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val510 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem503[_key509] = _val510
                        iprot.readMapEnd()
                        self.tagsList.append(_elem503)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype514, _size511) = iprot.readListBegin()
                    for _i515 in range(_size511):
                        _elem516 = iprot.readI32()
                        self.dataTypeList.append(_elem516)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DownsampleQueryResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter517 in self.paths:
                oprot.writeString(iter517.encode('utf-8') if sys.version_info[0] == 2 else iter517)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter518 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter518))
                for kiter519, viter520 in iter518.items():
                    oprot.writeString(kiter519.encode('utf-8') if sys.version_info[0] == 2 else kiter519)
                    oprot.writeString(viter520.encode('utf-8') if sys.version_info[0] == 2 else viter520)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter521 in self.dataTypeList:
                oprot.writeI32(iter521)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 5)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowColumnsReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowColumnsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowColumnsResp(object):
    """
    Attributes:
     - status
     - paths
     - tagsList
     - dataTypeList

    """


    def __init__(self, status=None, paths=None, tagsList=None, dataTypeList=None,):
        self.status = status
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype525, _size522) = iprot.readListBegin()
                    for _i526 in range(_size522):
                        _elem527 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem527)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype531, _size528) = iprot.readListBegin()
                    for _i532 in range(_size528):
                        _elem533 = {}
                        (_ktype535, _vtype536, _size534) = iprot.readMapBegin()
                        for _i538 in range(_size534):
                            _key539 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val540 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem533[_key539] = _val540
                        iprot.readMapEnd()
                        self.tagsList.append(_elem533)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype544, _size541) = iprot.readListBegin()
                    for _i545 in range(_size541):
                        _elem546 = iprot.readI32()
                        self.dataTypeList.append(_elem546)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowColumnsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter547 in self.paths:
                oprot.writeString(iter547.encode('utf-8') if sys.version_info[0] == 2 else iter547)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 3)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter548 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter548))
                for kiter549, viter550 in iter548.items():
                    oprot.writeString(kiter549.encode('utf-8') if sys.version_info[0] == 2 else kiter549)
                    oprot.writeString(viter550.encode('utf-8') if sys.version_info[0] == 2 else viter550)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter551 in self.dataTypeList:
                oprot.writeI32(iter551)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetReplicaNumReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetReplicaNumReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetReplicaNumResp(object):
    """
    Attributes:
     - status
     - replicaNum

    """


    def __init__(self, status=None, replicaNum=None,):
        self.status = status
        self.replicaNum = replicaNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.replicaNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetReplicaNumResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.replicaNum is not None:
            oprot.writeFieldBegin('replicaNum', TType.I32, 2)
            oprot.writeI32(self.replicaNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteSqlReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - remoteSession

    """


    def __init__(self, sessionId=None, statement=None, remoteSession=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.remoteSession = remoteSession

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.remoteSession = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteSqlReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.remoteSession is not None:
            oprot.writeFieldBegin('remoteSession', TType.BOOL, 3)
            oprot.writeBool(self.remoteSession)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteSqlResp(object):
    """
    Attributes:
     - status
     - type
     - paths
     - tagsList
     - dataTypeList
     - queryDataSet
     - keys
     - valuesList
     - replicaNum
     - pointsNum
     - aggregateType
     - parseErrorMsg
     - limit
     - offset
     - orderByPath
     - ascending
     - iginxInfos
     - storageEngineInfos
     - metaStorageInfos
     - localMetaStorageInfo
     - registerTaskInfos
     - jobId
     - jobState
     - jobStateMap
     - jobYamlPath
     - configs
     - loadCsvPath
     - sessionIDList
     - rules
     - UDFModulePath
     - usernames
     - userTypes
     - auths

    """


    def __init__(self, status=None, type=None, paths=None, tagsList=None, dataTypeList=None, queryDataSet=None, keys=None, valuesList=None, replicaNum=None, pointsNum=None, aggregateType=None, parseErrorMsg=None, limit=None, offset=None, orderByPath=None, ascending=None, iginxInfos=None, storageEngineInfos=None, metaStorageInfos=None, localMetaStorageInfo=None, registerTaskInfos=None, jobId=None, jobState=None, jobStateMap=None, jobYamlPath=None, configs=None, loadCsvPath=None, sessionIDList=None, rules=None, UDFModulePath=None, usernames=None, userTypes=None, auths=None,):
        self.status = status
        self.type = type
        self.paths = paths
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet
        self.keys = keys
        self.valuesList = valuesList
        self.replicaNum = replicaNum
        self.pointsNum = pointsNum
        self.aggregateType = aggregateType
        self.parseErrorMsg = parseErrorMsg
        self.limit = limit
        self.offset = offset
        self.orderByPath = orderByPath
        self.ascending = ascending
        self.iginxInfos = iginxInfos
        self.storageEngineInfos = storageEngineInfos
        self.metaStorageInfos = metaStorageInfos
        self.localMetaStorageInfo = localMetaStorageInfo
        self.registerTaskInfos = registerTaskInfos
        self.jobId = jobId
        self.jobState = jobState
        self.jobStateMap = jobStateMap
        self.jobYamlPath = jobYamlPath
        self.configs = configs
        self.loadCsvPath = loadCsvPath
        self.sessionIDList = sessionIDList
        self.rules = rules
        self.UDFModulePath = UDFModulePath
        self.usernames = usernames
        self.userTypes = userTypes
        self.auths = auths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype555, _size552) = iprot.readListBegin()
                    for _i556 in range(_size552):
                        _elem557 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem557)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype561, _size558) = iprot.readListBegin()
                    for _i562 in range(_size558):
                        _elem563 = {}
                        (_ktype565, _vtype566, _size564) = iprot.readMapBegin()
                        for _i568 in range(_size564):
                            _key569 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val570 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem563[_key569] = _val570
                        iprot.readMapEnd()
                        self.tagsList.append(_elem563)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype574, _size571) = iprot.readListBegin()
                    for _i575 in range(_size571):
                        _elem576 = iprot.readI32()
                        self.dataTypeList.append(_elem576)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.keys = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.valuesList = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.replicaNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.pointsNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.aggregateType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.parseErrorMsg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.orderByPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.ascending = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.LIST:
                    self.iginxInfos = []
                    (_etype580, _size577) = iprot.readListBegin()
                    for _i581 in range(_size577):
                        _elem582 = IginxInfo()
                        _elem582.read(iprot)
                        self.iginxInfos.append(_elem582)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.LIST:
                    self.storageEngineInfos = []
                    (_etype586, _size583) = iprot.readListBegin()
                    for _i587 in range(_size583):
                        _elem588 = StorageEngineInfo()
                        _elem588.read(iprot)
                        self.storageEngineInfos.append(_elem588)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.LIST:
                    self.metaStorageInfos = []
                    (_etype592, _size589) = iprot.readListBegin()
                    for _i593 in range(_size589):
                        _elem594 = MetaStorageInfo()
                        _elem594.read(iprot)
                        self.metaStorageInfos.append(_elem594)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.localMetaStorageInfo = LocalMetaStorageInfo()
                    self.localMetaStorageInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.LIST:
                    self.registerTaskInfos = []
                    (_etype598, _size595) = iprot.readListBegin()
                    for _i599 in range(_size595):
                        _elem600 = RegisterTaskInfo()
                        _elem600.read(iprot)
                        self.registerTaskInfos.append(_elem600)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I32:
                    self.jobState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.MAP:
                    self.jobStateMap = {}
                    (_ktype602, _vtype603, _size601) = iprot.readMapBegin()
                    for _i605 in range(_size601):
                        _key606 = iprot.readI32()
                        _val607 = []
                        (_etype611, _size608) = iprot.readListBegin()
                        for _i612 in range(_size608):
                            _elem613 = iprot.readI64()
                            _val607.append(_elem613)
                        iprot.readListEnd()
                        self.jobStateMap[_key606] = _val607
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.STRING:
                    self.jobYamlPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.MAP:
                    self.configs = {}
                    (_ktype615, _vtype616, _size614) = iprot.readMapBegin()
                    for _i618 in range(_size614):
                        _key619 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val620 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configs[_key619] = _val620
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.STRING:
                    self.loadCsvPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.LIST:
                    self.sessionIDList = []
                    (_etype624, _size621) = iprot.readListBegin()
                    for _i625 in range(_size621):
                        _elem626 = iprot.readI64()
                        self.sessionIDList.append(_elem626)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.MAP:
                    self.rules = {}
                    (_ktype628, _vtype629, _size627) = iprot.readMapBegin()
                    for _i631 in range(_size627):
                        _key632 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val633 = iprot.readBool()
                        self.rules[_key632] = _val633
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.STRING:
                    self.UDFModulePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.LIST:
                    self.usernames = []
                    (_etype637, _size634) = iprot.readListBegin()
                    for _i638 in range(_size634):
                        _elem639 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.usernames.append(_elem639)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.LIST:
                    self.userTypes = []
                    (_etype643, _size640) = iprot.readListBegin()
                    for _i644 in range(_size640):
                        _elem645 = iprot.readI32()
                        self.userTypes.append(_elem645)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.LIST:
                    self.auths = []
                    (_etype649, _size646) = iprot.readListBegin()
                    for _i650 in range(_size646):
                        _elem651 = set()
                        (_etype655, _size652) = iprot.readSetBegin()
                        for _i656 in range(_size652):
                            _elem657 = iprot.readI32()
                            _elem651.add(_elem657)
                        iprot.readSetEnd()
                        self.auths.append(_elem651)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteSqlResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter658 in self.paths:
                oprot.writeString(iter658.encode('utf-8') if sys.version_info[0] == 2 else iter658)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 4)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter659 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter659))
                for kiter660, viter661 in iter659.items():
                    oprot.writeString(kiter660.encode('utf-8') if sys.version_info[0] == 2 else kiter660)
                    oprot.writeString(viter661.encode('utf-8') if sys.version_info[0] == 2 else viter661)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter662 in self.dataTypeList:
                oprot.writeI32(iter662)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 6)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.STRING, 7)
            oprot.writeBinary(self.keys)
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.STRING, 8)
            oprot.writeBinary(self.valuesList)
            oprot.writeFieldEnd()
        if self.replicaNum is not None:
            oprot.writeFieldBegin('replicaNum', TType.I32, 9)
            oprot.writeI32(self.replicaNum)
            oprot.writeFieldEnd()
        if self.pointsNum is not None:
            oprot.writeFieldBegin('pointsNum', TType.I64, 10)
            oprot.writeI64(self.pointsNum)
            oprot.writeFieldEnd()
        if self.aggregateType is not None:
            oprot.writeFieldBegin('aggregateType', TType.I32, 11)
            oprot.writeI32(self.aggregateType)
            oprot.writeFieldEnd()
        if self.parseErrorMsg is not None:
            oprot.writeFieldBegin('parseErrorMsg', TType.STRING, 12)
            oprot.writeString(self.parseErrorMsg.encode('utf-8') if sys.version_info[0] == 2 else self.parseErrorMsg)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 13)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 14)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.orderByPath is not None:
            oprot.writeFieldBegin('orderByPath', TType.STRING, 15)
            oprot.writeString(self.orderByPath.encode('utf-8') if sys.version_info[0] == 2 else self.orderByPath)
            oprot.writeFieldEnd()
        if self.ascending is not None:
            oprot.writeFieldBegin('ascending', TType.BOOL, 16)
            oprot.writeBool(self.ascending)
            oprot.writeFieldEnd()
        if self.iginxInfos is not None:
            oprot.writeFieldBegin('iginxInfos', TType.LIST, 17)
            oprot.writeListBegin(TType.STRUCT, len(self.iginxInfos))
            for iter663 in self.iginxInfos:
                iter663.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageEngineInfos is not None:
            oprot.writeFieldBegin('storageEngineInfos', TType.LIST, 18)
            oprot.writeListBegin(TType.STRUCT, len(self.storageEngineInfos))
            for iter664 in self.storageEngineInfos:
                iter664.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metaStorageInfos is not None:
            oprot.writeFieldBegin('metaStorageInfos', TType.LIST, 19)
            oprot.writeListBegin(TType.STRUCT, len(self.metaStorageInfos))
            for iter665 in self.metaStorageInfos:
                iter665.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.localMetaStorageInfo is not None:
            oprot.writeFieldBegin('localMetaStorageInfo', TType.STRUCT, 20)
            self.localMetaStorageInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.registerTaskInfos is not None:
            oprot.writeFieldBegin('registerTaskInfos', TType.LIST, 21)
            oprot.writeListBegin(TType.STRUCT, len(self.registerTaskInfos))
            for iter666 in self.registerTaskInfos:
                iter666.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 22)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        if self.jobState is not None:
            oprot.writeFieldBegin('jobState', TType.I32, 23)
            oprot.writeI32(self.jobState)
            oprot.writeFieldEnd()
        if self.jobStateMap is not None:
            oprot.writeFieldBegin('jobStateMap', TType.MAP, 24)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.jobStateMap))
            for kiter667, viter668 in self.jobStateMap.items():
                oprot.writeI32(kiter667)
                oprot.writeListBegin(TType.I64, len(viter668))
                for iter669 in viter668:
                    oprot.writeI64(iter669)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.jobYamlPath is not None:
            oprot.writeFieldBegin('jobYamlPath', TType.STRING, 25)
            oprot.writeString(self.jobYamlPath.encode('utf-8') if sys.version_info[0] == 2 else self.jobYamlPath)
            oprot.writeFieldEnd()
        if self.configs is not None:
            oprot.writeFieldBegin('configs', TType.MAP, 26)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configs))
            for kiter670, viter671 in self.configs.items():
                oprot.writeString(kiter670.encode('utf-8') if sys.version_info[0] == 2 else kiter670)
                oprot.writeString(viter671.encode('utf-8') if sys.version_info[0] == 2 else viter671)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.loadCsvPath is not None:
            oprot.writeFieldBegin('loadCsvPath', TType.STRING, 27)
            oprot.writeString(self.loadCsvPath.encode('utf-8') if sys.version_info[0] == 2 else self.loadCsvPath)
            oprot.writeFieldEnd()
        if self.sessionIDList is not None:
            oprot.writeFieldBegin('sessionIDList', TType.LIST, 28)
            oprot.writeListBegin(TType.I64, len(self.sessionIDList))
            for iter672 in self.sessionIDList:
                oprot.writeI64(iter672)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rules is not None:
            oprot.writeFieldBegin('rules', TType.MAP, 29)
            oprot.writeMapBegin(TType.STRING, TType.BOOL, len(self.rules))
            for kiter673, viter674 in self.rules.items():
                oprot.writeString(kiter673.encode('utf-8') if sys.version_info[0] == 2 else kiter673)
                oprot.writeBool(viter674)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.UDFModulePath is not None:
            oprot.writeFieldBegin('UDFModulePath', TType.STRING, 30)
            oprot.writeString(self.UDFModulePath.encode('utf-8') if sys.version_info[0] == 2 else self.UDFModulePath)
            oprot.writeFieldEnd()
        if self.usernames is not None:
            oprot.writeFieldBegin('usernames', TType.LIST, 31)
            oprot.writeListBegin(TType.STRING, len(self.usernames))
            for iter675 in self.usernames:
                oprot.writeString(iter675.encode('utf-8') if sys.version_info[0] == 2 else iter675)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userTypes is not None:
            oprot.writeFieldBegin('userTypes', TType.LIST, 32)
            oprot.writeListBegin(TType.I32, len(self.userTypes))
            for iter676 in self.userTypes:
                oprot.writeI32(iter676)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.auths is not None:
            oprot.writeFieldBegin('auths', TType.LIST, 33)
            oprot.writeListBegin(TType.SET, len(self.auths))
            for iter677 in self.auths:
                oprot.writeSetBegin(TType.I32, len(iter677))
                for iter678 in iter677:
                    oprot.writeI32(iter678)
                oprot.writeSetEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UpdateUserReq(object):
    """
    Attributes:
     - sessionId
     - username
     - password
     - auths

    """


    def __init__(self, sessionId=None, username=None, password=None, auths=None,):
        self.sessionId = sessionId
        self.username = username
        self.password = password
        self.auths = auths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.auths = set()
                    (_etype682, _size679) = iprot.readSetBegin()
                    for _i683 in range(_size679):
                        _elem684 = iprot.readI32()
                        self.auths.add(_elem684)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateUserReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 3)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.auths is not None:
            oprot.writeFieldBegin('auths', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.auths))
            for iter685 in self.auths:
                oprot.writeI32(iter685)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddUserReq(object):
    """
    Attributes:
     - sessionId
     - username
     - password
     - auths

    """


    def __init__(self, sessionId=None, username=None, password=None, auths=None,):
        self.sessionId = sessionId
        self.username = username
        self.password = password
        self.auths = auths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.auths = set()
                    (_etype689, _size686) = iprot.readSetBegin()
                    for _i690 in range(_size686):
                        _elem691 = iprot.readI32()
                        self.auths.add(_elem691)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddUserReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 3)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.auths is not None:
            oprot.writeFieldBegin('auths', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.auths))
            for iter692 in self.auths:
                oprot.writeI32(iter692)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.auths is None:
            raise TProtocolException(message='Required field auths is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeleteUserReq(object):
    """
    Attributes:
     - sessionId
     - username

    """


    def __init__(self, sessionId=None, username=None,):
        self.sessionId = sessionId
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteUserReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetUserReq(object):
    """
    Attributes:
     - sessionId
     - usernames

    """


    def __init__(self, sessionId=None, usernames=None,):
        self.sessionId = sessionId
        self.usernames = usernames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.usernames = []
                    (_etype696, _size693) = iprot.readListBegin()
                    for _i697 in range(_size693):
                        _elem698 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.usernames.append(_elem698)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetUserReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.usernames is not None:
            oprot.writeFieldBegin('usernames', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.usernames))
            for iter699 in self.usernames:
                oprot.writeString(iter699.encode('utf-8') if sys.version_info[0] == 2 else iter699)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetUserResp(object):
    """
    Attributes:
     - status
     - usernames
     - userTypes
     - auths

    """


    def __init__(self, status=None, usernames=None, userTypes=None, auths=None,):
        self.status = status
        self.usernames = usernames
        self.userTypes = userTypes
        self.auths = auths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.usernames = []
                    (_etype703, _size700) = iprot.readListBegin()
                    for _i704 in range(_size700):
                        _elem705 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.usernames.append(_elem705)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.userTypes = []
                    (_etype709, _size706) = iprot.readListBegin()
                    for _i710 in range(_size706):
                        _elem711 = iprot.readI32()
                        self.userTypes.append(_elem711)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.auths = []
                    (_etype715, _size712) = iprot.readListBegin()
                    for _i716 in range(_size712):
                        _elem717 = set()
                        (_etype721, _size718) = iprot.readSetBegin()
                        for _i722 in range(_size718):
                            _elem723 = iprot.readI32()
                            _elem717.add(_elem723)
                        iprot.readSetEnd()
                        self.auths.append(_elem717)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetUserResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.usernames is not None:
            oprot.writeFieldBegin('usernames', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.usernames))
            for iter724 in self.usernames:
                oprot.writeString(iter724.encode('utf-8') if sys.version_info[0] == 2 else iter724)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userTypes is not None:
            oprot.writeFieldBegin('userTypes', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.userTypes))
            for iter725 in self.userTypes:
                oprot.writeI32(iter725)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.auths is not None:
            oprot.writeFieldBegin('auths', TType.LIST, 4)
            oprot.writeListBegin(TType.SET, len(self.auths))
            for iter726 in self.auths:
                oprot.writeSetBegin(TType.I32, len(iter726))
                for iter727 in iter726:
                    oprot.writeI32(iter727)
                oprot.writeSetEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetClusterInfoReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetClusterInfoReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IginxInfo(object):
    """
    Attributes:
     - id
     - ip
     - port

    """


    def __init__(self, id=None, ip=None, port=None,):
        self.id = id
        self.ip = ip
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IginxInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 2)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StorageEngineInfo(object):
    """
    Attributes:
     - id
     - ip
     - port
     - type
     - schemaPrefix
     - dataPrefix

    """


    def __init__(self, id=None, ip=None, port=None, type=None, schemaPrefix=None, dataPrefix=None,):
        self.id = id
        self.ip = ip
        self.port = port
        self.type = type
        self.schemaPrefix = schemaPrefix
        self.dataPrefix = dataPrefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.schemaPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.dataPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StorageEngineInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 2)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.schemaPrefix is not None:
            oprot.writeFieldBegin('schemaPrefix', TType.STRING, 5)
            oprot.writeString(self.schemaPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.schemaPrefix)
            oprot.writeFieldEnd()
        if self.dataPrefix is not None:
            oprot.writeFieldBegin('dataPrefix', TType.STRING, 6)
            oprot.writeString(self.dataPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.dataPrefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MetaStorageInfo(object):
    """
    Attributes:
     - ip
     - port
     - type

    """


    def __init__(self, ip=None, port=None, type=None,):
        self.ip = ip
        self.port = port
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MetaStorageInfo')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 3)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LocalMetaStorageInfo(object):
    """
    Attributes:
     - path

    """


    def __init__(self, path=None,):
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LocalMetaStorageInfo')
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 1)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetClusterInfoResp(object):
    """
    Attributes:
     - status
     - iginxInfos
     - storageEngineInfos
     - metaStorageInfos
     - localMetaStorageInfo

    """


    def __init__(self, status=None, iginxInfos=None, storageEngineInfos=None, metaStorageInfos=None, localMetaStorageInfo=None,):
        self.status = status
        self.iginxInfos = iginxInfos
        self.storageEngineInfos = storageEngineInfos
        self.metaStorageInfos = metaStorageInfos
        self.localMetaStorageInfo = localMetaStorageInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.iginxInfos = []
                    (_etype731, _size728) = iprot.readListBegin()
                    for _i732 in range(_size728):
                        _elem733 = IginxInfo()
                        _elem733.read(iprot)
                        self.iginxInfos.append(_elem733)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.storageEngineInfos = []
                    (_etype737, _size734) = iprot.readListBegin()
                    for _i738 in range(_size734):
                        _elem739 = StorageEngineInfo()
                        _elem739.read(iprot)
                        self.storageEngineInfos.append(_elem739)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.metaStorageInfos = []
                    (_etype743, _size740) = iprot.readListBegin()
                    for _i744 in range(_size740):
                        _elem745 = MetaStorageInfo()
                        _elem745.read(iprot)
                        self.metaStorageInfos.append(_elem745)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.localMetaStorageInfo = LocalMetaStorageInfo()
                    self.localMetaStorageInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetClusterInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.iginxInfos is not None:
            oprot.writeFieldBegin('iginxInfos', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.iginxInfos))
            for iter746 in self.iginxInfos:
                iter746.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageEngineInfos is not None:
            oprot.writeFieldBegin('storageEngineInfos', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.storageEngineInfos))
            for iter747 in self.storageEngineInfos:
                iter747.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metaStorageInfos is not None:
            oprot.writeFieldBegin('metaStorageInfos', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.metaStorageInfos))
            for iter748 in self.metaStorageInfos:
                iter748.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.localMetaStorageInfo is not None:
            oprot.writeFieldBegin('localMetaStorageInfo', TType.STRUCT, 5)
            self.localMetaStorageInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteStatementReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - fetchSize
     - timeout

    """


    def __init__(self, sessionId=None, statement=None, fetchSize=None, timeout=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 4)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteStatementResp(object):
    """
    Attributes:
     - status
     - type
     - queryId
     - columns
     - tagsList
     - dataTypeList
     - queryDataSet
     - warningMsg
     - exportStreamDir
     - exportCSV

    """


    def __init__(self, status=None, type=None, queryId=None, columns=None, tagsList=None, dataTypeList=None, queryDataSet=None, warningMsg=None, exportStreamDir=None, exportCSV=None,):
        self.status = status
        self.type = type
        self.queryId = queryId
        self.columns = columns
        self.tagsList = tagsList
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet
        self.warningMsg = warningMsg
        self.exportStreamDir = exportStreamDir
        self.exportCSV = exportCSV

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype752, _size749) = iprot.readListBegin()
                    for _i753 in range(_size749):
                        _elem754 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem754)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype758, _size755) = iprot.readListBegin()
                    for _i759 in range(_size755):
                        _elem760 = {}
                        (_ktype762, _vtype763, _size761) = iprot.readMapBegin()
                        for _i765 in range(_size761):
                            _key766 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val767 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem760[_key766] = _val767
                        iprot.readMapEnd()
                        self.tagsList.append(_elem760)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype771, _size768) = iprot.readListBegin()
                    for _i772 in range(_size768):
                        _elem773 = iprot.readI32()
                        self.dataTypeList.append(_elem773)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSetV2()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.warningMsg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.exportStreamDir = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.exportCSV = ExportCSV()
                    self.exportCSV.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteStatementResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 3)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter774 in self.columns:
                oprot.writeString(iter774.encode('utf-8') if sys.version_info[0] == 2 else iter774)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 5)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter775 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter775))
                for kiter776, viter777 in iter775.items():
                    oprot.writeString(kiter776.encode('utf-8') if sys.version_info[0] == 2 else kiter776)
                    oprot.writeString(viter777.encode('utf-8') if sys.version_info[0] == 2 else viter777)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataTypeList))
            for iter778 in self.dataTypeList:
                oprot.writeI32(iter778)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 7)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.warningMsg is not None:
            oprot.writeFieldBegin('warningMsg', TType.STRING, 8)
            oprot.writeString(self.warningMsg.encode('utf-8') if sys.version_info[0] == 2 else self.warningMsg)
            oprot.writeFieldEnd()
        if self.exportStreamDir is not None:
            oprot.writeFieldBegin('exportStreamDir', TType.STRING, 9)
            oprot.writeString(self.exportStreamDir.encode('utf-8') if sys.version_info[0] == 2 else self.exportStreamDir)
            oprot.writeFieldEnd()
        if self.exportCSV is not None:
            oprot.writeFieldBegin('exportCSV', TType.STRUCT, 10)
            self.exportCSV.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExportCSV(object):
    """
    Attributes:
     - exportCsvPath
     - isExportHeader
     - delimiter
     - isOptionallyQuote
     - quote
     - escaped
     - recordSeparator

    """


    def __init__(self, exportCsvPath=None, isExportHeader=None, delimiter=None, isOptionallyQuote=None, quote=None, escaped=None, recordSeparator=None,):
        self.exportCsvPath = exportCsvPath
        self.isExportHeader = isExportHeader
        self.delimiter = delimiter
        self.isOptionallyQuote = isOptionallyQuote
        self.quote = quote
        self.escaped = escaped
        self.recordSeparator = recordSeparator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.exportCsvPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isExportHeader = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.delimiter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isOptionallyQuote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.quote = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I16:
                    self.escaped = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.recordSeparator = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExportCSV')
        if self.exportCsvPath is not None:
            oprot.writeFieldBegin('exportCsvPath', TType.STRING, 1)
            oprot.writeString(self.exportCsvPath.encode('utf-8') if sys.version_info[0] == 2 else self.exportCsvPath)
            oprot.writeFieldEnd()
        if self.isExportHeader is not None:
            oprot.writeFieldBegin('isExportHeader', TType.BOOL, 2)
            oprot.writeBool(self.isExportHeader)
            oprot.writeFieldEnd()
        if self.delimiter is not None:
            oprot.writeFieldBegin('delimiter', TType.STRING, 3)
            oprot.writeString(self.delimiter.encode('utf-8') if sys.version_info[0] == 2 else self.delimiter)
            oprot.writeFieldEnd()
        if self.isOptionallyQuote is not None:
            oprot.writeFieldBegin('isOptionallyQuote', TType.BOOL, 4)
            oprot.writeBool(self.isOptionallyQuote)
            oprot.writeFieldEnd()
        if self.quote is not None:
            oprot.writeFieldBegin('quote', TType.I16, 5)
            oprot.writeI16(self.quote)
            oprot.writeFieldEnd()
        if self.escaped is not None:
            oprot.writeFieldBegin('escaped', TType.I16, 6)
            oprot.writeI16(self.escaped)
            oprot.writeFieldEnd()
        if self.recordSeparator is not None:
            oprot.writeFieldBegin('recordSeparator', TType.STRING, 7)
            oprot.writeString(self.recordSeparator.encode('utf-8') if sys.version_info[0] == 2 else self.recordSeparator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.exportCsvPath is None:
            raise TProtocolException(message='Required field exportCsvPath is unset!')
        if self.isExportHeader is None:
            raise TProtocolException(message='Required field isExportHeader is unset!')
        if self.delimiter is None:
            raise TProtocolException(message='Required field delimiter is unset!')
        if self.isOptionallyQuote is None:
            raise TProtocolException(message='Required field isOptionallyQuote is unset!')
        if self.quote is None:
            raise TProtocolException(message='Required field quote is unset!')
        if self.escaped is None:
            raise TProtocolException(message='Required field escaped is unset!')
        if self.recordSeparator is None:
            raise TProtocolException(message='Required field recordSeparator is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryDataSetV2(object):
    """
    Attributes:
     - valuesList
     - bitmapList

    """


    def __init__(self, valuesList=None, bitmapList=None,):
        self.valuesList = valuesList
        self.bitmapList = bitmapList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype782, _size779) = iprot.readListBegin()
                    for _i783 in range(_size779):
                        _elem784 = iprot.readBinary()
                        self.valuesList.append(_elem784)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype788, _size785) = iprot.readListBegin()
                    for _i789 in range(_size785):
                        _elem790 = iprot.readBinary()
                        self.bitmapList.append(_elem790)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryDataSetV2')
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter791 in self.valuesList:
                oprot.writeBinary(iter791)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter792 in self.bitmapList:
                oprot.writeBinary(iter792)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CloseStatementReq(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CloseStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FetchResultsReq(object):
    """
    Attributes:
     - sessionId
     - queryId
     - fetchSize
     - timeout

    """


    def __init__(self, sessionId=None, queryId=None, fetchSize=None, timeout=None,):
        self.sessionId = sessionId
        self.queryId = queryId
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchResultsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 4)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FetchResultsResp(object):
    """
    Attributes:
     - status
     - hasMoreResults
     - queryDataSet

    """


    def __init__(self, status=None, hasMoreResults=None, queryDataSet=None,):
        self.status = status
        self.hasMoreResults = hasMoreResults
        self.queryDataSet = queryDataSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hasMoreResults = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.queryDataSet = QueryDataSetV2()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchResultsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.hasMoreResults is not None:
            oprot.writeFieldBegin('hasMoreResults', TType.BOOL, 2)
            oprot.writeBool(self.hasMoreResults)
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 3)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.hasMoreResults is None:
            raise TProtocolException(message='Required field hasMoreResults is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadCSVReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - csvFileName

    """


    def __init__(self, sessionId=None, statement=None, csvFileName=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.csvFileName = csvFileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.csvFileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadCSVReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.csvFileName is not None:
            oprot.writeFieldBegin('csvFileName', TType.STRING, 3)
            oprot.writeString(self.csvFileName.encode('utf-8') if sys.version_info[0] == 2 else self.csvFileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.csvFileName is None:
            raise TProtocolException(message='Required field csvFileName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadCSVResp(object):
    """
    Attributes:
     - status
     - columns
     - recordsNum
     - parseErrorMsg

    """


    def __init__(self, status=None, columns=None, recordsNum=None, parseErrorMsg=None,):
        self.status = status
        self.columns = columns
        self.recordsNum = recordsNum
        self.parseErrorMsg = parseErrorMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype796, _size793) = iprot.readListBegin()
                    for _i797 in range(_size793):
                        _elem798 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem798)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.recordsNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.parseErrorMsg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadCSVResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter799 in self.columns:
                oprot.writeString(iter799.encode('utf-8') if sys.version_info[0] == 2 else iter799)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.recordsNum is not None:
            oprot.writeFieldBegin('recordsNum', TType.I64, 3)
            oprot.writeI64(self.recordsNum)
            oprot.writeFieldEnd()
        if self.parseErrorMsg is not None:
            oprot.writeFieldBegin('parseErrorMsg', TType.STRING, 4)
            oprot.writeString(self.parseErrorMsg.encode('utf-8') if sys.version_info[0] == 2 else self.parseErrorMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadUDFReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - udfFile
     - isRemote

    """


    def __init__(self, sessionId=None, statement=None, udfFile=None, isRemote=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.udfFile = udfFile
        self.isRemote = isRemote

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.udfFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isRemote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadUDFReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.udfFile is not None:
            oprot.writeFieldBegin('udfFile', TType.STRING, 3)
            oprot.writeBinary(self.udfFile)
            oprot.writeFieldEnd()
        if self.isRemote is not None:
            oprot.writeFieldBegin('isRemote', TType.BOOL, 4)
            oprot.writeBool(self.isRemote)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.isRemote is None:
            raise TProtocolException(message='Required field isRemote is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadUDFResp(object):
    """
    Attributes:
     - status
     - parseErrorMsg
     - UDFModulePath

    """


    def __init__(self, status=None, parseErrorMsg=None, UDFModulePath=None,):
        self.status = status
        self.parseErrorMsg = parseErrorMsg
        self.UDFModulePath = UDFModulePath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parseErrorMsg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.UDFModulePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadUDFResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.parseErrorMsg is not None:
            oprot.writeFieldBegin('parseErrorMsg', TType.STRING, 2)
            oprot.writeString(self.parseErrorMsg.encode('utf-8') if sys.version_info[0] == 2 else self.parseErrorMsg)
            oprot.writeFieldEnd()
        if self.UDFModulePath is not None:
            oprot.writeFieldBegin('UDFModulePath', TType.STRING, 3)
            oprot.writeString(self.UDFModulePath.encode('utf-8') if sys.version_info[0] == 2 else self.UDFModulePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TaskInfo(object):
    """
    Attributes:
     - taskType
     - dataFlowType
     - timeout
     - sqlList
     - pyTaskName

    """


    def __init__(self, taskType=None, dataFlowType=None, timeout=None, sqlList=None, pyTaskName=None,):
        self.taskType = taskType
        self.dataFlowType = dataFlowType
        self.timeout = timeout
        self.sqlList = sqlList
        self.pyTaskName = pyTaskName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.taskType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataFlowType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sqlList = []
                    (_etype803, _size800) = iprot.readListBegin()
                    for _i804 in range(_size800):
                        _elem805 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sqlList.append(_elem805)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pyTaskName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TaskInfo')
        if self.taskType is not None:
            oprot.writeFieldBegin('taskType', TType.I32, 1)
            oprot.writeI32(self.taskType)
            oprot.writeFieldEnd()
        if self.dataFlowType is not None:
            oprot.writeFieldBegin('dataFlowType', TType.I32, 2)
            oprot.writeI32(self.dataFlowType)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 3)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.sqlList is not None:
            oprot.writeFieldBegin('sqlList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.sqlList))
            for iter806 in self.sqlList:
                oprot.writeString(iter806.encode('utf-8') if sys.version_info[0] == 2 else iter806)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pyTaskName is not None:
            oprot.writeFieldBegin('pyTaskName', TType.STRING, 5)
            oprot.writeString(self.pyTaskName.encode('utf-8') if sys.version_info[0] == 2 else self.pyTaskName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.taskType is None:
            raise TProtocolException(message='Required field taskType is unset!')
        if self.dataFlowType is None:
            raise TProtocolException(message='Required field dataFlowType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommitTransformJobReq(object):
    """
    Attributes:
     - sessionId
     - taskList
     - exportType
     - fileName
     - schedule
     - stopOnFailure
     - notification

    """


    def __init__(self, sessionId=None, taskList=None, exportType=None, fileName=None, schedule=None, stopOnFailure=None, notification=None,):
        self.sessionId = sessionId
        self.taskList = taskList
        self.exportType = exportType
        self.fileName = fileName
        self.schedule = schedule
        self.stopOnFailure = stopOnFailure
        self.notification = notification

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.taskList = []
                    (_etype810, _size807) = iprot.readListBegin()
                    for _i811 in range(_size807):
                        _elem812 = TaskInfo()
                        _elem812.read(iprot)
                        self.taskList.append(_elem812)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.exportType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.schedule = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.stopOnFailure = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.notification = Notification()
                    self.notification.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitTransformJobReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.taskList is not None:
            oprot.writeFieldBegin('taskList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.taskList))
            for iter813 in self.taskList:
                iter813.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exportType is not None:
            oprot.writeFieldBegin('exportType', TType.I32, 3)
            oprot.writeI32(self.exportType)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 4)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.schedule is not None:
            oprot.writeFieldBegin('schedule', TType.STRING, 5)
            oprot.writeString(self.schedule.encode('utf-8') if sys.version_info[0] == 2 else self.schedule)
            oprot.writeFieldEnd()
        if self.stopOnFailure is not None:
            oprot.writeFieldBegin('stopOnFailure', TType.BOOL, 6)
            oprot.writeBool(self.stopOnFailure)
            oprot.writeFieldEnd()
        if self.notification is not None:
            oprot.writeFieldBegin('notification', TType.STRUCT, 7)
            self.notification.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.taskList is None:
            raise TProtocolException(message='Required field taskList is unset!')
        if self.exportType is None:
            raise TProtocolException(message='Required field exportType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Notification(object):
    """
    Attributes:
     - email

    """


    def __init__(self, email=None,):
        self.email = email

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.email = Email()
                    self.email.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Notification')
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRUCT, 1)
            self.email.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Email(object):
    """
    Attributes:
     - hostName
     - smtpPort
     - username
     - password
     - fromAddr
     - toAddrs

    """


    def __init__(self, hostName=None, smtpPort=None, username=None, password=None, fromAddr=None, toAddrs=None,):
        self.hostName = hostName
        self.smtpPort = smtpPort
        self.username = username
        self.password = password
        self.fromAddr = fromAddr
        self.toAddrs = toAddrs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hostName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.smtpPort = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.fromAddr = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.toAddrs = []
                    (_etype817, _size814) = iprot.readListBegin()
                    for _i818 in range(_size814):
                        _elem819 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.toAddrs.append(_elem819)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Email')
        if self.hostName is not None:
            oprot.writeFieldBegin('hostName', TType.STRING, 1)
            oprot.writeString(self.hostName.encode('utf-8') if sys.version_info[0] == 2 else self.hostName)
            oprot.writeFieldEnd()
        if self.smtpPort is not None:
            oprot.writeFieldBegin('smtpPort', TType.STRING, 2)
            oprot.writeString(self.smtpPort.encode('utf-8') if sys.version_info[0] == 2 else self.smtpPort)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 3)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.fromAddr is not None:
            oprot.writeFieldBegin('fromAddr', TType.STRING, 5)
            oprot.writeString(self.fromAddr.encode('utf-8') if sys.version_info[0] == 2 else self.fromAddr)
            oprot.writeFieldEnd()
        if self.toAddrs is not None:
            oprot.writeFieldBegin('toAddrs', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.toAddrs))
            for iter820 in self.toAddrs:
                oprot.writeString(iter820.encode('utf-8') if sys.version_info[0] == 2 else iter820)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hostName is None:
            raise TProtocolException(message='Required field hostName is unset!')
        if self.smtpPort is None:
            raise TProtocolException(message='Required field smtpPort is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.fromAddr is None:
            raise TProtocolException(message='Required field fromAddr is unset!')
        if self.toAddrs is None:
            raise TProtocolException(message='Required field toAddrs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommitTransformJobResp(object):
    """
    Attributes:
     - status
     - jobId

    """


    def __init__(self, status=None, jobId=None,):
        self.status = status
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitTransformJobResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 2)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jobId is None:
            raise TProtocolException(message='Required field jobId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryTransformJobStatusReq(object):
    """
    Attributes:
     - sessionId
     - jobId

    """


    def __init__(self, sessionId=None, jobId=None,):
        self.sessionId = sessionId
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryTransformJobStatusReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 2)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.jobId is None:
            raise TProtocolException(message='Required field jobId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryTransformJobStatusResp(object):
    """
    Attributes:
     - status
     - jobState

    """


    def __init__(self, status=None, jobState=None,):
        self.status = status
        self.jobState = jobState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.jobState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryTransformJobStatusResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jobState is not None:
            oprot.writeFieldBegin('jobState', TType.I32, 2)
            oprot.writeI32(self.jobState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jobState is None:
            raise TProtocolException(message='Required field jobState is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowEligibleJobReq(object):
    """
    Attributes:
     - sessionId
     - jobState

    """


    def __init__(self, sessionId=None, jobState=None,):
        self.sessionId = sessionId
        self.jobState = jobState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.jobState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowEligibleJobReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.jobState is not None:
            oprot.writeFieldBegin('jobState', TType.I32, 2)
            oprot.writeI32(self.jobState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowEligibleJobResp(object):
    """
    Attributes:
     - status
     - jobStateMap

    """


    def __init__(self, status=None, jobStateMap=None,):
        self.status = status
        self.jobStateMap = jobStateMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.jobStateMap = {}
                    (_ktype822, _vtype823, _size821) = iprot.readMapBegin()
                    for _i825 in range(_size821):
                        _key826 = iprot.readI32()
                        _val827 = []
                        (_etype831, _size828) = iprot.readListBegin()
                        for _i832 in range(_size828):
                            _elem833 = iprot.readI64()
                            _val827.append(_elem833)
                        iprot.readListEnd()
                        self.jobStateMap[_key826] = _val827
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowEligibleJobResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jobStateMap is not None:
            oprot.writeFieldBegin('jobStateMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.jobStateMap))
            for kiter834, viter835 in self.jobStateMap.items():
                oprot.writeI32(kiter834)
                oprot.writeListBegin(TType.I64, len(viter835))
                for iter836 in viter835:
                    oprot.writeI64(iter836)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jobStateMap is None:
            raise TProtocolException(message='Required field jobStateMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CancelTransformJobReq(object):
    """
    Attributes:
     - sessionId
     - jobId

    """


    def __init__(self, sessionId=None, jobId=None,):
        self.sessionId = sessionId
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CancelTransformJobReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 2)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.jobId is None:
            raise TProtocolException(message='Required field jobId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RegisterTaskReq(object):
    """
    Attributes:
     - sessionId
     - filePath
     - UDFClassPairs
     - types
     - moduleFile
     - isRemote

    """


    def __init__(self, sessionId=None, filePath=None, UDFClassPairs=None, types=None, moduleFile=None, isRemote=None,):
        self.sessionId = sessionId
        self.filePath = filePath
        self.UDFClassPairs = UDFClassPairs
        self.types = types
        self.moduleFile = moduleFile
        self.isRemote = isRemote

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.UDFClassPairs = []
                    (_etype840, _size837) = iprot.readListBegin()
                    for _i841 in range(_size837):
                        _elem842 = UDFClassPair()
                        _elem842.read(iprot)
                        self.UDFClassPairs.append(_elem842)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.types = []
                    (_etype846, _size843) = iprot.readListBegin()
                    for _i847 in range(_size843):
                        _elem848 = iprot.readI32()
                        self.types.append(_elem848)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.moduleFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isRemote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RegisterTaskReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.filePath is not None:
            oprot.writeFieldBegin('filePath', TType.STRING, 2)
            oprot.writeString(self.filePath.encode('utf-8') if sys.version_info[0] == 2 else self.filePath)
            oprot.writeFieldEnd()
        if self.UDFClassPairs is not None:
            oprot.writeFieldBegin('UDFClassPairs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.UDFClassPairs))
            for iter849 in self.UDFClassPairs:
                iter849.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.types))
            for iter850 in self.types:
                oprot.writeI32(iter850)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.moduleFile is not None:
            oprot.writeFieldBegin('moduleFile', TType.STRING, 5)
            oprot.writeBinary(self.moduleFile)
            oprot.writeFieldEnd()
        if self.isRemote is not None:
            oprot.writeFieldBegin('isRemote', TType.BOOL, 6)
            oprot.writeBool(self.isRemote)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.filePath is None:
            raise TProtocolException(message='Required field filePath is unset!')
        if self.UDFClassPairs is None:
            raise TProtocolException(message='Required field UDFClassPairs is unset!')
        if self.types is None:
            raise TProtocolException(message='Required field types is unset!')
        if self.moduleFile is None:
            raise TProtocolException(message='Required field moduleFile is unset!')
        if self.isRemote is None:
            raise TProtocolException(message='Required field isRemote is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DropTaskReq(object):
    """
    Attributes:
     - sessionId
     - name

    """


    def __init__(self, sessionId=None, name=None,):
        self.sessionId = sessionId
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DropTaskReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRegisterTaskInfoReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRegisterTaskInfoReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IpPortPair(object):
    """
    Attributes:
     - ip
     - port

    """


    def __init__(self, ip=None, port=None,):
        self.ip = ip
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IpPortPair')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RegisterTaskInfo(object):
    """
    Attributes:
     - name
     - className
     - fileName
     - ipPortPair
     - type

    """


    def __init__(self, name=None, className=None, fileName=None, ipPortPair=None, type=None,):
        self.name = name
        self.className = className
        self.fileName = fileName
        self.ipPortPair = ipPortPair
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.ipPortPair = []
                    (_etype854, _size851) = iprot.readListBegin()
                    for _i855 in range(_size851):
                        _elem856 = IpPortPair()
                        _elem856.read(iprot)
                        self.ipPortPair.append(_elem856)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RegisterTaskInfo')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 3)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.ipPortPair is not None:
            oprot.writeFieldBegin('ipPortPair', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.ipPortPair))
            for iter857 in self.ipPortPair:
                iter857.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 5)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.fileName is None:
            raise TProtocolException(message='Required field fileName is unset!')
        if self.ipPortPair is None:
            raise TProtocolException(message='Required field ipPortPair is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRegisterTaskInfoResp(object):
    """
    Attributes:
     - status
     - registerTaskInfoList

    """


    def __init__(self, status=None, registerTaskInfoList=None,):
        self.status = status
        self.registerTaskInfoList = registerTaskInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.registerTaskInfoList = []
                    (_etype861, _size858) = iprot.readListBegin()
                    for _i862 in range(_size858):
                        _elem863 = RegisterTaskInfo()
                        _elem863.read(iprot)
                        self.registerTaskInfoList.append(_elem863)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRegisterTaskInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.registerTaskInfoList is not None:
            oprot.writeFieldBegin('registerTaskInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.registerTaskInfoList))
            for iter864 in self.registerTaskInfoList:
                iter864.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CurveMatchReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startKey
     - endKey
     - curveQuery
     - curveUnit

    """


    def __init__(self, sessionId=None, paths=None, startKey=None, endKey=None, curveQuery=None, curveUnit=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startKey = startKey
        self.endKey = endKey
        self.curveQuery = curveQuery
        self.curveUnit = curveUnit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype868, _size865) = iprot.readListBegin()
                    for _i869 in range(_size865):
                        _elem870 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem870)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.curveQuery = []
                    (_etype874, _size871) = iprot.readListBegin()
                    for _i875 in range(_size871):
                        _elem876 = iprot.readDouble()
                        self.curveQuery.append(_elem876)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.curveUnit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CurveMatchReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter877 in self.paths:
                oprot.writeString(iter877.encode('utf-8') if sys.version_info[0] == 2 else iter877)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 3)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 4)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.curveQuery is not None:
            oprot.writeFieldBegin('curveQuery', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.curveQuery))
            for iter878 in self.curveQuery:
                oprot.writeDouble(iter878)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.curveUnit is not None:
            oprot.writeFieldBegin('curveUnit', TType.I64, 6)
            oprot.writeI64(self.curveUnit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        if self.curveQuery is None:
            raise TProtocolException(message='Required field curveQuery is unset!')
        if self.curveUnit is None:
            raise TProtocolException(message='Required field curveUnit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CurveMatchResp(object):
    """
    Attributes:
     - status
     - matchedPath
     - matchedKey

    """


    def __init__(self, status=None, matchedPath=None, matchedKey=None,):
        self.status = status
        self.matchedPath = matchedPath
        self.matchedKey = matchedKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.matchedPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.matchedKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CurveMatchResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.matchedPath is not None:
            oprot.writeFieldBegin('matchedPath', TType.STRING, 2)
            oprot.writeString(self.matchedPath.encode('utf-8') if sys.version_info[0] == 2 else self.matchedPath)
            oprot.writeFieldEnd()
        if self.matchedKey is not None:
            oprot.writeFieldBegin('matchedKey', TType.I64, 3)
            oprot.writeI64(self.matchedKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetMetaReq(object):
    """
    Attributes:
     - byCache

    """


    def __init__(self, byCache=None,):
        self.byCache = byCache

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.byCache = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMetaReq')
        if self.byCache is not None:
            oprot.writeFieldBegin('byCache', TType.BOOL, 1)
            oprot.writeBool(self.byCache)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.byCache is None:
            raise TProtocolException(message='Required field byCache is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Fragment(object):
    """
    Attributes:
     - storageUnitId
     - startKey
     - endKey
     - startTs
     - endTs

    """


    def __init__(self, storageUnitId=None, startKey=None, endKey=None, startTs=None, endTs=None,):
        self.storageUnitId = storageUnitId
        self.startKey = startKey
        self.endKey = endKey
        self.startTs = startTs
        self.endTs = endTs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageUnitId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.startKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.endKey = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.startTs = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.endTs = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Fragment')
        if self.storageUnitId is not None:
            oprot.writeFieldBegin('storageUnitId', TType.STRING, 1)
            oprot.writeString(self.storageUnitId.encode('utf-8') if sys.version_info[0] == 2 else self.storageUnitId)
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.I64, 2)
            oprot.writeI64(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.I64, 3)
            oprot.writeI64(self.endKey)
            oprot.writeFieldEnd()
        if self.startTs is not None:
            oprot.writeFieldBegin('startTs', TType.STRING, 4)
            oprot.writeString(self.startTs.encode('utf-8') if sys.version_info[0] == 2 else self.startTs)
            oprot.writeFieldEnd()
        if self.endTs is not None:
            oprot.writeFieldBegin('endTs', TType.STRING, 5)
            oprot.writeString(self.endTs.encode('utf-8') if sys.version_info[0] == 2 else self.endTs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageUnitId is None:
            raise TProtocolException(message='Required field storageUnitId is unset!')
        if self.startKey is None:
            raise TProtocolException(message='Required field startKey is unset!')
        if self.endKey is None:
            raise TProtocolException(message='Required field endKey is unset!')
        if self.startTs is None:
            raise TProtocolException(message='Required field startTs is unset!')
        if self.endTs is None:
            raise TProtocolException(message='Required field endTs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Storage(object):
    """
    Attributes:
     - id
     - ip
     - port
     - type

    """


    def __init__(self, id=None, ip=None, port=None, type=None,):
        self.id = id
        self.ip = ip
        self.port = port
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.port = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Storage')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 2)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I64, 3)
            oprot.writeI64(self.port)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StorageUnit(object):
    """
    Attributes:
     - id
     - masterId
     - storageId

    """


    def __init__(self, id=None, masterId=None, storageId=None,):
        self.id = id
        self.masterId = masterId
        self.storageId = storageId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.masterId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.storageId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StorageUnit')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.masterId is not None:
            oprot.writeFieldBegin('masterId', TType.STRING, 2)
            oprot.writeString(self.masterId.encode('utf-8') if sys.version_info[0] == 2 else self.masterId)
            oprot.writeFieldEnd()
        if self.storageId is not None:
            oprot.writeFieldBegin('storageId', TType.I64, 3)
            oprot.writeI64(self.storageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.masterId is None:
            raise TProtocolException(message='Required field masterId is unset!')
        if self.storageId is None:
            raise TProtocolException(message='Required field storageId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetMetaResp(object):
    """
    Attributes:
     - fragments
     - storages
     - storageUnits

    """


    def __init__(self, fragments=None, storages=None, storageUnits=None,):
        self.fragments = fragments
        self.storages = storages
        self.storageUnits = storageUnits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fragments = []
                    (_etype882, _size879) = iprot.readListBegin()
                    for _i883 in range(_size879):
                        _elem884 = Fragment()
                        _elem884.read(iprot)
                        self.fragments.append(_elem884)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.storages = []
                    (_etype888, _size885) = iprot.readListBegin()
                    for _i889 in range(_size885):
                        _elem890 = Storage()
                        _elem890.read(iprot)
                        self.storages.append(_elem890)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.storageUnits = []
                    (_etype894, _size891) = iprot.readListBegin()
                    for _i895 in range(_size891):
                        _elem896 = StorageUnit()
                        _elem896.read(iprot)
                        self.storageUnits.append(_elem896)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMetaResp')
        if self.fragments is not None:
            oprot.writeFieldBegin('fragments', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.fragments))
            for iter897 in self.fragments:
                iter897.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storages is not None:
            oprot.writeFieldBegin('storages', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.storages))
            for iter898 in self.storages:
                iter898.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageUnits is not None:
            oprot.writeFieldBegin('storageUnits', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.storageUnits))
            for iter899 in self.storageUnits:
                iter899.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragments is None:
            raise TProtocolException(message='Required field fragments is unset!')
        if self.storages is None:
            raise TProtocolException(message='Required field storages is unset!')
        if self.storageUnits is None:
            raise TProtocolException(message='Required field storageUnits is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DebugInfoReq(object):
    """
    Attributes:
     - payloadType
     - payload

    """


    def __init__(self, payloadType=None, payload=None,):
        self.payloadType = payloadType
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.payloadType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DebugInfoReq')
        if self.payloadType is not None:
            oprot.writeFieldBegin('payloadType', TType.I32, 1)
            oprot.writeI32(self.payloadType)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 2)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.payloadType is None:
            raise TProtocolException(message='Required field payloadType is unset!')
        if self.payload is None:
            raise TProtocolException(message='Required field payload is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DebugInfoResp(object):
    """
    Attributes:
     - status
     - payload

    """


    def __init__(self, status=None, payload=None,):
        self.status = status
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DebugInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 2)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RemovedStorageEngineInfo(object):
    """
    Attributes:
     - ip
     - port
     - schemaPrefix
     - dataPrefix

    """


    def __init__(self, ip=None, port=None, schemaPrefix=None, dataPrefix=None,):
        self.ip = ip
        self.port = port
        self.schemaPrefix = schemaPrefix
        self.dataPrefix = dataPrefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.schemaPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dataPrefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemovedStorageEngineInfo')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.schemaPrefix is not None:
            oprot.writeFieldBegin('schemaPrefix', TType.STRING, 3)
            oprot.writeString(self.schemaPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.schemaPrefix)
            oprot.writeFieldEnd()
        if self.dataPrefix is not None:
            oprot.writeFieldBegin('dataPrefix', TType.STRING, 4)
            oprot.writeString(self.dataPrefix.encode('utf-8') if sys.version_info[0] == 2 else self.dataPrefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        if self.schemaPrefix is None:
            raise TProtocolException(message='Required field schemaPrefix is unset!')
        if self.dataPrefix is None:
            raise TProtocolException(message='Required field dataPrefix is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RemoveStorageEngineReq(object):
    """
    Attributes:
     - sessionId
     - removedStorageEngineInfoList

    """


    def __init__(self, sessionId=None, removedStorageEngineInfoList=None,):
        self.sessionId = sessionId
        self.removedStorageEngineInfoList = removedStorageEngineInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.removedStorageEngineInfoList = []
                    (_etype903, _size900) = iprot.readListBegin()
                    for _i904 in range(_size900):
                        _elem905 = RemovedStorageEngineInfo()
                        _elem905.read(iprot)
                        self.removedStorageEngineInfoList.append(_elem905)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemoveStorageEngineReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.removedStorageEngineInfoList is not None:
            oprot.writeFieldBegin('removedStorageEngineInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.removedStorageEngineInfoList))
            for iter906 in self.removedStorageEngineInfoList:
                iter906.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.removedStorageEngineInfoList is None:
            raise TProtocolException(message='Required field removedStorageEngineInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowSessionIDReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowSessionIDReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowSessionIDResp(object):
    """
    Attributes:
     - status
     - sessionIDList

    """


    def __init__(self, status=None, sessionIDList=None,):
        self.status = status
        self.sessionIDList = sessionIDList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sessionIDList = []
                    (_etype910, _size907) = iprot.readListBegin()
                    for _i911 in range(_size907):
                        _elem912 = iprot.readI64()
                        self.sessionIDList.append(_elem912)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowSessionIDResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.sessionIDList is not None:
            oprot.writeFieldBegin('sessionIDList', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.sessionIDList))
            for iter913 in self.sessionIDList:
                oprot.writeI64(iter913)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.sessionIDList is None:
            raise TProtocolException(message='Required field sessionIDList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowRulesReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowRulesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowRulesResp(object):
    """
    Attributes:
     - status
     - rules

    """


    def __init__(self, status=None, rules=None,):
        self.status = status
        self.rules = rules

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.rules = {}
                    (_ktype915, _vtype916, _size914) = iprot.readMapBegin()
                    for _i918 in range(_size914):
                        _key919 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val920 = iprot.readBool()
                        self.rules[_key919] = _val920
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowRulesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.rules is not None:
            oprot.writeFieldBegin('rules', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.BOOL, len(self.rules))
            for kiter921, viter922 in self.rules.items():
                oprot.writeString(kiter921.encode('utf-8') if sys.version_info[0] == 2 else kiter921)
                oprot.writeBool(viter922)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.rules is None:
            raise TProtocolException(message='Required field rules is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetRulesReq(object):
    """
    Attributes:
     - sessionId
     - rulesChange

    """


    def __init__(self, sessionId=None, rulesChange=None,):
        self.sessionId = sessionId
        self.rulesChange = rulesChange

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.rulesChange = {}
                    (_ktype924, _vtype925, _size923) = iprot.readMapBegin()
                    for _i927 in range(_size923):
                        _key928 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val929 = iprot.readBool()
                        self.rulesChange[_key928] = _val929
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetRulesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.rulesChange is not None:
            oprot.writeFieldBegin('rulesChange', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.BOOL, len(self.rulesChange))
            for kiter930, viter931 in self.rulesChange.items():
                oprot.writeString(kiter930.encode('utf-8') if sys.version_info[0] == 2 else kiter930)
                oprot.writeBool(viter931)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.rulesChange is None:
            raise TProtocolException(message='Required field rulesChange is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FileChunk(object):
    """
    Attributes:
     - fileName
     - offset
     - data
     - chunkSize

    """


    def __init__(self, fileName=None, offset=None, data=None, chunkSize=None,):
        self.fileName = fileName
        self.offset = offset
        self.data = data
        self.chunkSize = chunkSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.chunkSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FileChunk')
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 1)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 3)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.chunkSize is not None:
            oprot.writeFieldBegin('chunkSize', TType.I64, 4)
            oprot.writeI64(self.chunkSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileName is None:
            raise TProtocolException(message='Required field fileName is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.data is None:
            raise TProtocolException(message='Required field data is unset!')
        if self.chunkSize is None:
            raise TProtocolException(message='Required field chunkSize is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UploadFileReq(object):
    """
    Attributes:
     - sessionId
     - fileChunk

    """


    def __init__(self, sessionId=None, fileChunk=None,):
        self.sessionId = sessionId
        self.fileChunk = fileChunk

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.fileChunk = FileChunk()
                    self.fileChunk.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UploadFileReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.fileChunk is not None:
            oprot.writeFieldBegin('fileChunk', TType.STRUCT, 2)
            self.fileChunk.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.fileChunk is None:
            raise TProtocolException(message='Required field fileChunk is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UploadFileResp(object):
    """
    Attributes:
     - status

    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UploadFileResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Status)
Status.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'subStatus', (TType.STRUCT, [Status, None], False), None, ),  # 3
)
all_structs.append(UDFClassPair)
UDFClassPair.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'classPath', 'UTF8', None, ),  # 2
)
all_structs.append(OpenSessionReq)
OpenSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)
all_structs.append(OpenSessionResp)
OpenSessionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I64, 'sessionId', None, None, ),  # 2
)
all_structs.append(CloseSessionReq)
CloseSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(DeleteColumnsReq)
DeleteColumnsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 3
    (4, TType.I32, 'filterType', None, None, ),  # 4
)
all_structs.append(InsertColumnRecordsReq)
InsertColumnRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'keys', 'BINARY', None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
)
all_structs.append(InsertNonAlignedColumnRecordsReq)
InsertNonAlignedColumnRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'keys', 'BINARY', None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
)
all_structs.append(InsertRowRecordsReq)
InsertRowRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'keys', 'BINARY', None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
)
all_structs.append(InsertNonAlignedRowRecordsReq)
InsertNonAlignedRowRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'keys', 'BINARY', None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
)
all_structs.append(DeleteDataInColumnsReq)
DeleteDataInColumnsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 5
    (6, TType.I32, 'filterType', None, None, ),  # 6
    (7, TType.I32, 'timePrecision', None, None, ),  # 7
)
all_structs.append(QueryDataSet)
QueryDataSet.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'keys', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 3
)
all_structs.append(QueryDataReq)
QueryDataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 5
    (6, TType.I32, 'timePrecision', None, None, ),  # 6
    (7, TType.I32, 'filterType', None, None, ),  # 7
)
all_structs.append(QueryDataResp)
QueryDataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRUCT, 'queryDataSet', [QueryDataSet, None], None, ),  # 5
)
all_structs.append(AddStorageEnginesReq)
AddStorageEnginesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'storageEngines', (TType.STRUCT, [StorageEngine, None], False), None, ),  # 2
)
all_structs.append(AlterStorageEngineReq)
AlterStorageEngineReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'engineId', None, None, ),  # 2
    (3, TType.MAP, 'newParams', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(StorageEngine)
StorageEngine.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
    (4, TType.MAP, 'extraParams', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(AggregateQueryReq)
AggregateQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.I32, 'aggregateType', None, None, ),  # 5
    (6, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 6
    (7, TType.I32, 'timePrecision', None, None, ),  # 7
    (8, TType.I32, 'filterType', None, None, ),  # 8
)
all_structs.append(AggregateQueryResp)
AggregateQueryResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRING, 'keys', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'valuesList', 'BINARY', None, ),  # 6
)
all_structs.append(LastQueryReq)
LastQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 4
    (5, TType.I32, 'timePrecision', None, None, ),  # 5
    (6, TType.I32, 'filterType', None, None, ),  # 6
)
all_structs.append(LastQueryResp)
LastQueryResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRUCT, 'queryDataSet', [QueryDataSet, None], None, ),  # 5
)
all_structs.append(DownsampleQueryReq)
DownsampleQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.I32, 'aggregateType', None, None, ),  # 5
    (6, TType.I64, 'precision', None, None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), False), None, ),  # 7
    (8, TType.I32, 'timePrecision', None, None, ),  # 8
    (9, TType.I32, 'filterType', None, None, ),  # 9
)
all_structs.append(DownsampleQueryResp)
DownsampleQueryResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRUCT, 'queryDataSet', [QueryDataSet, None], None, ),  # 5
)
all_structs.append(ShowColumnsReq)
ShowColumnsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(ShowColumnsResp)
ShowColumnsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(GetReplicaNumReq)
GetReplicaNumReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(GetReplicaNumResp)
GetReplicaNumResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I32, 'replicaNum', None, None, ),  # 2
)
all_structs.append(ExecuteSqlReq)
ExecuteSqlReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'remoteSession', None, None, ),  # 3
)
all_structs.append(ExecuteSqlResp)
ExecuteSqlResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 5
    (6, TType.STRUCT, 'queryDataSet', [QueryDataSet, None], None, ),  # 6
    (7, TType.STRING, 'keys', 'BINARY', None, ),  # 7
    (8, TType.STRING, 'valuesList', 'BINARY', None, ),  # 8
    (9, TType.I32, 'replicaNum', None, None, ),  # 9
    (10, TType.I64, 'pointsNum', None, None, ),  # 10
    (11, TType.I32, 'aggregateType', None, None, ),  # 11
    (12, TType.STRING, 'parseErrorMsg', 'UTF8', None, ),  # 12
    (13, TType.I32, 'limit', None, None, ),  # 13
    (14, TType.I32, 'offset', None, None, ),  # 14
    (15, TType.STRING, 'orderByPath', 'UTF8', None, ),  # 15
    (16, TType.BOOL, 'ascending', None, None, ),  # 16
    (17, TType.LIST, 'iginxInfos', (TType.STRUCT, [IginxInfo, None], False), None, ),  # 17
    (18, TType.LIST, 'storageEngineInfos', (TType.STRUCT, [StorageEngineInfo, None], False), None, ),  # 18
    (19, TType.LIST, 'metaStorageInfos', (TType.STRUCT, [MetaStorageInfo, None], False), None, ),  # 19
    (20, TType.STRUCT, 'localMetaStorageInfo', [LocalMetaStorageInfo, None], None, ),  # 20
    (21, TType.LIST, 'registerTaskInfos', (TType.STRUCT, [RegisterTaskInfo, None], False), None, ),  # 21
    (22, TType.I64, 'jobId', None, None, ),  # 22
    (23, TType.I32, 'jobState', None, None, ),  # 23
    (24, TType.MAP, 'jobStateMap', (TType.I32, None, TType.LIST, (TType.I64, None, False), False), None, ),  # 24
    (25, TType.STRING, 'jobYamlPath', 'UTF8', None, ),  # 25
    (26, TType.MAP, 'configs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 26
    (27, TType.STRING, 'loadCsvPath', 'UTF8', None, ),  # 27
    (28, TType.LIST, 'sessionIDList', (TType.I64, None, False), None, ),  # 28
    (29, TType.MAP, 'rules', (TType.STRING, 'UTF8', TType.BOOL, None, False), None, ),  # 29
    (30, TType.STRING, 'UDFModulePath', 'UTF8', None, ),  # 30
    (31, TType.LIST, 'usernames', (TType.STRING, 'UTF8', False), None, ),  # 31
    (32, TType.LIST, 'userTypes', (TType.I32, None, False), None, ),  # 32
    (33, TType.LIST, 'auths', (TType.SET, (TType.I32, None, False), False), None, ),  # 33
)
all_structs.append(UpdateUserReq)
UpdateUserReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'password', 'UTF8', None, ),  # 3
    (4, TType.SET, 'auths', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(AddUserReq)
AddUserReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'password', 'UTF8', None, ),  # 3
    (4, TType.SET, 'auths', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(DeleteUserReq)
DeleteUserReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
)
all_structs.append(GetUserReq)
GetUserReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'usernames', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(GetUserResp)
GetUserResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'usernames', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'userTypes', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'auths', (TType.SET, (TType.I32, None, False), False), None, ),  # 4
)
all_structs.append(GetClusterInfoReq)
GetClusterInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(IginxInfo)
IginxInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'ip', 'UTF8', None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)
all_structs.append(StorageEngineInfo)
StorageEngineInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'ip', 'UTF8', None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
    (5, TType.STRING, 'schemaPrefix', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'dataPrefix', 'UTF8', None, ),  # 6
)
all_structs.append(MetaStorageInfo)
MetaStorageInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRING, 'type', 'UTF8', None, ),  # 3
)
all_structs.append(LocalMetaStorageInfo)
LocalMetaStorageInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'path', 'UTF8', None, ),  # 1
)
all_structs.append(GetClusterInfoResp)
GetClusterInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'iginxInfos', (TType.STRUCT, [IginxInfo, None], False), None, ),  # 2
    (3, TType.LIST, 'storageEngineInfos', (TType.STRUCT, [StorageEngineInfo, None], False), None, ),  # 3
    (4, TType.LIST, 'metaStorageInfos', (TType.STRUCT, [MetaStorageInfo, None], False), None, ),  # 4
    (5, TType.STRUCT, 'localMetaStorageInfo', [LocalMetaStorageInfo, None], None, ),  # 5
)
all_structs.append(ExecuteStatementReq)
ExecuteStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'timeout', None, None, ),  # 4
)
all_structs.append(ExecuteStatementResp)
ExecuteStatementResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.I64, 'queryId', None, None, ),  # 3
    (4, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.I32, None, False), None, ),  # 6
    (7, TType.STRUCT, 'queryDataSet', [QueryDataSetV2, None], None, ),  # 7
    (8, TType.STRING, 'warningMsg', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'exportStreamDir', 'UTF8', None, ),  # 9
    (10, TType.STRUCT, 'exportCSV', [ExportCSV, None], None, ),  # 10
)
all_structs.append(ExportCSV)
ExportCSV.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'exportCsvPath', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'isExportHeader', None, None, ),  # 2
    (3, TType.STRING, 'delimiter', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isOptionallyQuote', None, None, ),  # 4
    (5, TType.I16, 'quote', None, None, ),  # 5
    (6, TType.I16, 'escaped', None, None, ),  # 6
    (7, TType.STRING, 'recordSeparator', 'UTF8', None, ),  # 7
)
all_structs.append(QueryDataSetV2)
QueryDataSetV2.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(CloseStatementReq)
CloseStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
)
all_structs.append(FetchResultsReq)
FetchResultsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'timeout', None, None, ),  # 4
)
all_structs.append(FetchResultsResp)
FetchResultsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.BOOL, 'hasMoreResults', None, None, ),  # 2
    (3, TType.STRUCT, 'queryDataSet', [QueryDataSetV2, None], None, ),  # 3
)
all_structs.append(LoadCSVReq)
LoadCSVReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'csvFileName', 'UTF8', None, ),  # 3
)
all_structs.append(LoadCSVResp)
LoadCSVResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'recordsNum', None, None, ),  # 3
    (4, TType.STRING, 'parseErrorMsg', 'UTF8', None, ),  # 4
)
all_structs.append(LoadUDFReq)
LoadUDFReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'udfFile', 'BINARY', None, ),  # 3
    (4, TType.BOOL, 'isRemote', None, None, ),  # 4
)
all_structs.append(LoadUDFResp)
LoadUDFResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.STRING, 'parseErrorMsg', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'UDFModulePath', 'UTF8', None, ),  # 3
)
all_structs.append(TaskInfo)
TaskInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'taskType', None, None, ),  # 1
    (2, TType.I32, 'dataFlowType', None, None, ),  # 2
    (3, TType.I64, 'timeout', None, None, ),  # 3
    (4, TType.LIST, 'sqlList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'pyTaskName', 'UTF8', None, ),  # 5
)
all_structs.append(CommitTransformJobReq)
CommitTransformJobReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'taskList', (TType.STRUCT, [TaskInfo, None], False), None, ),  # 2
    (3, TType.I32, 'exportType', None, None, ),  # 3
    (4, TType.STRING, 'fileName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'schedule', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'stopOnFailure', None, None, ),  # 6
    (7, TType.STRUCT, 'notification', [Notification, None], None, ),  # 7
)
all_structs.append(Notification)
Notification.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'email', [Email, None], None, ),  # 1
)
all_structs.append(Email)
Email.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hostName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'smtpPort', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'username', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'password', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'fromAddr', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'toAddrs', (TType.STRING, 'UTF8', False), None, ),  # 6
)
all_structs.append(CommitTransformJobResp)
CommitTransformJobResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I64, 'jobId', None, None, ),  # 2
)
all_structs.append(QueryTransformJobStatusReq)
QueryTransformJobStatusReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'jobId', None, None, ),  # 2
)
all_structs.append(QueryTransformJobStatusResp)
QueryTransformJobStatusResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.I32, 'jobState', None, None, ),  # 2
)
all_structs.append(ShowEligibleJobReq)
ShowEligibleJobReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I32, 'jobState', None, None, ),  # 2
)
all_structs.append(ShowEligibleJobResp)
ShowEligibleJobResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.MAP, 'jobStateMap', (TType.I32, None, TType.LIST, (TType.I64, None, False), False), None, ),  # 2
)
all_structs.append(CancelTransformJobReq)
CancelTransformJobReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'jobId', None, None, ),  # 2
)
all_structs.append(RegisterTaskReq)
RegisterTaskReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'filePath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'UDFClassPairs', (TType.STRUCT, [UDFClassPair, None], False), None, ),  # 3
    (4, TType.LIST, 'types', (TType.I32, None, False), None, ),  # 4
    (5, TType.STRING, 'moduleFile', 'BINARY', None, ),  # 5
    (6, TType.BOOL, 'isRemote', None, None, ),  # 6
)
all_structs.append(DropTaskReq)
DropTaskReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)
all_structs.append(GetRegisterTaskInfoReq)
GetRegisterTaskInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(IpPortPair)
IpPortPair.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
)
all_structs.append(RegisterTaskInfo)
RegisterTaskInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'fileName', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'ipPortPair', (TType.STRUCT, [IpPortPair, None], False), None, ),  # 4
    (5, TType.I32, 'type', None, None, ),  # 5
)
all_structs.append(GetRegisterTaskInfoResp)
GetRegisterTaskInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'registerTaskInfoList', (TType.STRUCT, [RegisterTaskInfo, None], False), None, ),  # 2
)
all_structs.append(CurveMatchReq)
CurveMatchReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startKey', None, None, ),  # 3
    (4, TType.I64, 'endKey', None, None, ),  # 4
    (5, TType.LIST, 'curveQuery', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.I64, 'curveUnit', None, None, ),  # 6
)
all_structs.append(CurveMatchResp)
CurveMatchResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.STRING, 'matchedPath', 'UTF8', None, ),  # 2
    (3, TType.I64, 'matchedKey', None, None, ),  # 3
)
all_structs.append(GetMetaReq)
GetMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'byCache', None, None, ),  # 1
)
all_structs.append(Fragment)
Fragment.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storageUnitId', 'UTF8', None, ),  # 1
    (2, TType.I64, 'startKey', None, None, ),  # 2
    (3, TType.I64, 'endKey', None, None, ),  # 3
    (4, TType.STRING, 'startTs', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'endTs', 'UTF8', None, ),  # 5
)
all_structs.append(Storage)
Storage.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'ip', 'UTF8', None, ),  # 2
    (3, TType.I64, 'port', None, None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)
all_structs.append(StorageUnit)
StorageUnit.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'masterId', 'UTF8', None, ),  # 2
    (3, TType.I64, 'storageId', None, None, ),  # 3
)
all_structs.append(GetMetaResp)
GetMetaResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fragments', (TType.STRUCT, [Fragment, None], False), None, ),  # 1
    (2, TType.LIST, 'storages', (TType.STRUCT, [Storage, None], False), None, ),  # 2
    (3, TType.LIST, 'storageUnits', (TType.STRUCT, [StorageUnit, None], False), None, ),  # 3
)
all_structs.append(DebugInfoReq)
DebugInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'payloadType', None, None, ),  # 1
    (2, TType.STRING, 'payload', 'BINARY', None, ),  # 2
)
all_structs.append(DebugInfoResp)
DebugInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.STRING, 'payload', 'BINARY', None, ),  # 2
)
all_structs.append(RemovedStorageEngineInfo)
RemovedStorageEngineInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRING, 'schemaPrefix', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'dataPrefix', 'UTF8', None, ),  # 4
)
all_structs.append(RemoveStorageEngineReq)
RemoveStorageEngineReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'removedStorageEngineInfoList', (TType.STRUCT, [RemovedStorageEngineInfo, None], False), None, ),  # 2
)
all_structs.append(ShowSessionIDReq)
ShowSessionIDReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(ShowSessionIDResp)
ShowSessionIDResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.LIST, 'sessionIDList', (TType.I64, None, False), None, ),  # 2
)
all_structs.append(ShowRulesReq)
ShowRulesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(ShowRulesResp)
ShowRulesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
    (2, TType.MAP, 'rules', (TType.STRING, 'UTF8', TType.BOOL, None, False), None, ),  # 2
)
all_structs.append(SetRulesReq)
SetRulesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.MAP, 'rulesChange', (TType.STRING, 'UTF8', TType.BOOL, None, False), None, ),  # 2
)
all_structs.append(FileChunk)
FileChunk.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fileName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.STRING, 'data', 'BINARY', None, ),  # 3
    (4, TType.I64, 'chunkSize', None, None, ),  # 4
)
all_structs.append(UploadFileReq)
UploadFileReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRUCT, 'fileChunk', [FileChunk, None], None, ),  # 2
)
all_structs.append(UploadFileResp)
UploadFileResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
